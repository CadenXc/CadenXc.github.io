[{"title":"游戏引擎学习之旅（1）","url":"/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89/","content":"现状c++：\n\n学了CS106L，AP-1400，作业大部分完成了；图形学基础：\nGAMES101的视频课程看完了，作业写到了MVP变换渲染小奶牛。游戏引擎：\nGAMES104的视频教程视频，没做作业;\n学过SDL2；\n跟着Brackeys入门了Godot的基本操作，对游戏引擎要实现的有一个基本的概念。软件工程：\n读了一些经典书籍：《代码大全》《人月神话》《软件开发心理学》；\n其他相关：《Doom启示录》。\n\n经历我先是学了两天的Vulkan，然后看The Cherno 的 游戏引擎系列的s1~s15。\n比较不自量力的是没有学过OpenGL，想着直接跳入Vulkan，自己用Vulkan写视频里的渲染部分代码。然后就发现Vulkan确实复杂，考虑到我以后很长一段时间都会向The Cherno学习，还是先去学习他的OpenGL系列比较好。而且他后面也用Vulkan，学会了OpenGL应该会让我更好学习Vulkan。\n所以我就暂停学习引擎，去学习OpenGL了。现在看了20节的OpenGL，感觉OpenGL确实比Vulkan简单多了。绘制让我想到了SDL2，MVP变换让我想起了GAMES101，许多知识点开始连起来了。\n想法要有自知之明，脚踏实地。\nThe Cherno的视频确实很好，我学到了许多。\n我接下来就是学习OpenGL，然后是学习游戏引擎，然后我就可以开始为Godot等开源代码做贡献了。\n游戏和游戏引擎真的很有吸引力。游戏设计我不太懂，但是做游戏引擎的成就感和学到的技术是实打实的。技术成就真的会让我开心。\n接下来的系列文章，大多是我的想法体会。如果你也在学习的路上，不妨来看看。\n","tags":["游戏引擎"]},{"title":"游戏引擎学习之旅（2）事件系统","url":"/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"视频学到了S022，分析一下Hazel的事件系统是如何实现的。\n\n\n先看看Application类里如何处理jj下面这里的 变量层栈的for循环里，if(e.Handled)为true，就退出不处理了\nvoid Application::OnEvent(Event&amp; e)&#123;\tHZ_PROFILE_FUNCTION();\tEventDispatcher dispatcher(e);\tdispatcher.Dispatch&lt;WindowCloseEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowClose));\tdispatcher.Dispatch&lt;WindowResizeEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowResize));\tfor (auto it = m_LayerStack.rbegin(); it != m_LayerStack.rend(); ++it)\t&#123;\t\tif (e.Handled) \t\t\tbreak;\t\t(*it)-&gt;OnEvent(e);\t&#125;&#125;\n这里显示用了一个dispatcher来处理窗口关闭和窗口重定义大小，这里的写法是判断事件类型是否符合传入的Callback处理函数，如果匹配了，就设置Handled为true（看下面的OnWindowClose返回的true，这样异或为true）。看下面的循环，Handled为true会直接退出。\ndispatch// F will be deduced by the compilertemplate&lt;typename T, typename F&gt;bool Dispatch(const F&amp; func)&#123;\tif (m_Event.GetEventType() == T::GetStaticType())\t&#123;\t\tm_Event.Handled |= func(static_cast&lt;T&amp;&gt;(m_Event));\t\treturn true;\t&#125;\treturn false;&#125;\n\n\n    bool Application::OnWindowClose(WindowCloseEvent&amp; e)    &#123;        m_Running = false;        return true;    &#125;\n\n下面这个事件处理返回的就是false，表示这个事件没有处理完，穿透层，下一层继续处理。\n  bool ImGuiLayer::OnMouseButtonPressedEvent(MouseButtonPressedEvent&amp; e) &#123;ImGuiIO&amp; io = ImGui::GetIO();io.MouseDown[e.GetMouseButton()] = true;      ET_CORE_TRACE(e.ToString());      return false;  &#125;\n\n这个Handled可以在层设置阻挡，ImGuiLayer这里的设置：阻挡成功Handled就设置为true。\nvoid ImGuiLayer::OnEvent(Event&amp; e)&#123;\tif (m_BlockEvents)\t&#123;\t\tImGuiIO&amp; io = ImGui::GetIO();\t\te.Handled |= e.IsInCategory(EventCategoryMouse) &amp; io.WantCaptureMouse;\t\te.Handled |= e.IsInCategory(EventCategoryKeyboard) &amp; io.WantCaptureKeyboard;\t&#125;&#125;\n\n那么如何设置事件类型呢？在事件发生的时候，glfw会自动调用下面我们在窗口初始化的时候设置的回调函数，这里的data.EventCallback(evnet)就是设置Event的类型\n        // Set GLFW callbacks        glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)        &#123;            WindowData&amp; data = *(WindowData*)glfwGetWindowUserPointer(window);            data.Width = width;            data.Height = height;              WindowResizeEvent event(width, height);            data.EventCallback(event);        &#125;);\n\ndata的类型就是下面的函数指针\nusing EventCallbackFn = std::function&lt;void(Event&amp;)&gt;;\n这里提供了Event类型，EventDispatcher提供了处理事件的函数。这就是我对整个事件系统的理解了。\n","tags":["游戏引擎"]},{"title":"游戏引擎学习之旅（3）渲染器重构","url":"/2025/05/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%E6%B8%B2%E6%9F%93%E5%99%A8%E9%87%8D%E6%9E%84/","content":"重构的理由跟着视频写为什么需要重构呢？你只需要从视频或者代码库里把东习 steal 出来不就行了吗？这是因为我在看他的视频的时候感觉非常熟悉，他在讲 OpenGL 的时候抽象出了一个类似的渲染器（Renderer），我想就把学习 OpenGL 写的代码哪过来不久行了吗？。确实行了，屏幕上有预期的图片绘出。但是他的设计思路是把渲染的 API 和具体的图形学 API 的实现分开，方便后续扩展API，比如Vulkan，可以让使用引擎的人不知道渲染的具体实现。我的当前的代码结构没有这个抽象的 API ，直接就是 OpenGL 的具体实现，这就我直接加上的代码就不合适了。于是就开启了重构工作。\n开始重构我从 The Cherno 那里 steal 了抽象 API ，我要做的就是让我的现在类继承抽象的 API 。我感觉没什么困难的，可是我基本上是第一次做这种类似的工作，修改了一处就报错，代码无法运行，有一种无从下手的感觉。从 The Cherno 那里 steal 的抽象 API是阻挡我修改的难关，不仅成员函数的参数和数量不同，里面的数据也进行了封装，成员变量的类型和数量不同，不能直接加上继承就让代码运行。种种限制让我对着代码发愁。这很挫败，难道我应该跟着视频走，回退到没有合并代码的版本吗？有没有什么技巧可以帮我重构呢？\n还真有，我想起来了这本著名的《重构 改善既有代码的设计》，之前我一直用不上就没有读，现在是时候读读这本书了。这本书给了我很大的帮助。对我来说学到的重要的思想是：小步走，让代码保持可工作状态和重构会让开发更快。这让我静下心来，不想着一步到位，而是慢慢调整代码。我一步步得重构了原本的代码，并且加深了我对这整个渲染器的设计的理解。\n在重构中理解设计思路 我在The Cherno 的 Layout 的布局的 API 传入的参是 自定义的枚举类型，float2 就表示两个float类型的布局，把原本的类型和个数这个参数给些在了一起，我在用这个自定义类形的参数替代原来的 float 和 unsigned int 时， 想着这里，肯定有一个把这个变量变换为原来的两个的函数，我果然看到了两个相关的函数，一个计算大小，一个返回类型。\n 他的顶点数组的创建用的是Create()函数，我之前没有意思到，我重构的时候意识才到这个函数的作用是让调用渲染器时只包含抽象 API 的头文件而不用与 具体的OpenGL类的图形学 API 的实现相关。\nRendererAPI，RenderCommand，Renderer类之间的关系是后者调用前者。 渲染器的 Draw 和 Clear 是一个静态函数时，不用具体实现一个Renderer类。这里整个Renderer的实现的接口都是方便引擎的使用者调用。我在这里重构了几天既让用户方便，也让开发者有一个结构更加合理的代码库，方便后续开发。\n想法 这种跟上思路的感觉很棒。\n这次没有学太多的新东西，基本上是 OpenGL 系列里的东西，这是的重点是重构。\n我确实做的是重构，写了几天，运行的结果还是和之前一模一样。难怪书里开头问了一个问题：如何跟经理解释重构的意义。\n书里说重构的最佳时机就是在添加新功能之前，这个我也认同，我就是在添加相机功能之前重构代码。\n提高了我重构的意识。当代码报了一个头文件循环包含的错误时，我想这是一个坏味道，就检查了其他的代码的头文件的包含，去掉多余的。\n在重构的过程中真正学到了东西，而不是从theCherno那里steal。也难怪Peter Norvig说要learning by doing了。\n 我看书的时候意识到theCherno的教学中的代码也是在进行重构。先在屏幕上花画出一个三角型，在不改变显示效果的情况下对代码进行修改，提高代码的可读性和可扩展性，提高代码质量。\n","tags":["游戏引擎"]},{"title":"英语学习经验分享","url":"/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/","content":"我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。\n\n\n下面是我学习英语的经验。\n\n把手机语言设置为英文；\n读英文的技术书籍和文档；\n看英文电影、动画；\n把游戏语言调成英语；\n写英文博客；\n听英文播客。\n\n有些是一次性的。如把手机语言设置为英文。发朋友圈、微博说自己接下来要读完某本英文书，或是每天读半小时，通过一次轻松的行为安排了之后的一段时间。买一个会员，报个考试，通过公开承诺来约束自己。\n最好的学习英语的方式就是用英语学习自己想学的东西。我在读英文技术书籍的时候会刻意挑选英文原版来锻炼自己的英文水平。国外大学的公开课英文的视频、网站和作业同时学技术和英文，是个一石二鸟的方式。\n听播客是一个很好的英语输入途径。听不懂没关系，重要的是培养这个感觉。找到自己的i+1的材料，听就行了。\n\n资源推荐罗肖尼Shawney的bilibili主页，里面有有关英语学习的视频牛顿探索加拿大的英语学习播客单集 ，别忘了shownote的书籍推荐学会提问，这本是提高写作技巧的书。Steam 上的 Life is Strange Remastered，注意把语言调成英文。\n","tags":["英语"]},{"title":"阅读《代码大全》","url":"/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/","content":"《代码大全》我读了两遍，先是读到英文版，后来又读了一边中文版。读英文版时，我还想着“routine”该怎么翻译，结果看中文翻译翻成了“子程序”，意思没原文丰富。中英文版都不错完全推荐。\n这本书讲的内容真的是软件工程的基础，跟我看完了感觉在各个方面长见识，但又很难说是什么，感觉就是为设计软件打了地基，知识成为了我的血液。书里的代码编写、变量命名、注释等我在其他的书籍视频里看过好几次，这本书把软件的方方面面串联起来，给了我一个大的画画。先读这本书会为软件工程打一个很好的基础。\n全书令我影响深刻的观点论述有：\n\n用隐喻来学习；\n软件工程就是管理复杂度；\n不要陷进语言，自己定义用法；\n伪代码编程过程；\n最后几章的关于人的个性，布局排版的艺术。\n\n有些东西确实不太懂，毕竟我还没有在真实的工业环境里工作过，设计、编码、测试等技能没有经过检验。不只这本书，《clean code》里的后半部分我就不懂；《程序开发心理学》我读得挺有意思，但是每章结束后问管理者和程序员的问题我无法回答；不过《人月神话》没有讨论什么技术，谈的是思想，写得也好，不愧对它的声誉。\n","tags":["书籍"]}]