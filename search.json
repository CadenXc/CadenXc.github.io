[{"title":"Vulkan Debug心得","url":"/2026/02/24/Vulkan-Debug%E5%BF%83%E5%BE%97/","content":"最近在写毕业设计，一个Vulkan混合渲染器。Vulkan极其繁琐的API和合格的显式控制给本就困难的图形学Debug蒙上了又一道阴影。下面总结了的几条我用上的技巧，有更好的方法欢迎在评论里指出，我会满怀感激得尝试。\n验证层与结构化日志首先是启用Vulkan 验证层。同时配合使用开源日志库 spdlog 实现一个自定义的日志类。使用不同颜色的l日志标识。这样当前验证层出错时能一眼看出。\n给资源起名字当验证层报错时，默认情况下它只会告诉你：“VkImage 0x12ab34cd 的布局不正确”。在一个拥有几十张贴图的混合管线中，这种报错无异于大海捞针。\n可以使用下面的函数SetDebugName() 来给资源起名。\n    void VulkanContext::SetDebugName(uint64_t handle, VkObjectType type, const char* name)    &#123;        if (handle == 0 || name == nullptr)        &#123;            return;        &#125;        auto func = (PFN_vkSetDebugUtilsObjectNameEXT)vkGetDeviceProcAddr(GetDevice(), &quot;vkSetDebugUtilsObjectNameEXT&quot;);        if (func)        &#123;            VkDebugUtilsObjectNameInfoEXT nameInfo&#123; VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT &#125;;            nameInfo.objectType = type;            nameInfo.objectHandle = handle;            nameInfo.pObjectName = name;            func(GetDevice(), &amp;nameInfo);        &#125;    &#125;\n\n\n\n下面这个的作用？\n#define VK_CHECK(result) \\    do &#123; \\        VkResult res = (result); \\        if (res != VK_SUCCESS) &#123; \\            throw std::runtime_error(&quot;Vulkan error: &quot; + std::to_string(res)); \\        &#125; \\    &#125; while(0)\n\n\n可视化图形编程debug重要的还是可视化。使用开源库Imgui，可以很好的实现可视化Debug，可以通过 UI 面板实时切换显示 Albedo、Normal、Motion Vector 或 Depth，可以调整相机，光源位置来。\n因为本项目中我采用了RenderGraph管理渲染管线，所以实现了一键导出 Mermaid 流程图代码的功能。这样能可视化查看当前RenderGraph的拓扑逻辑。这个大佬的FrameGraph可视化做得很好。\nRenderDoc在我这次开发中没用到，不过官方文档有提到。\n","tags":["Vulkan","Debug"]},{"title":"AI 编码的观点和经验分享","url":"/2026/02/12/AI-%E7%BC%96%E7%A0%81%E7%9A%84%E8%A7%82%E7%82%B9%E5%92%8C%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/","content":"这里提到的“AI”，涵盖了我用过的通用大模型（如 GPT, Gemini），以及集成在编辑器中的编程 AI（如 Cursor, Gemini Code Assist 等）。观念：工具的进化\nAI 相当于一个新的工具，我觉得应该尽快学会使用它。我看过一个非常贴切的比喻：在没有 AI 之前，程序员编程好比马车夫驾驶马车；而 AI 的出现，相当于把马车升级为了汽车。\nAI 虽然比马车更加强大，但说到底还是一个工具。我们要做就是尽快学习使用它，完成从“赶马车”到“开汽车”的升级。即使工具升级了，有些东西是不变的——比如“拉客经验”，这就相当于程序员的内功心法：数据结构与算法。所以不用担心是否被替代了，这也符合我们斯多葛主义者的精神。\n趋势：从搜索到生成\n传统的浏览器搜索和 Stack Overflow 就像是那辆略显落后的马车。SEO (搜索引擎优化) 已显颓势，而 GEO (生成式引擎优化) 则日益火爆。\n我平时有什么问题也更倾向于问 AI，一来它会给我聚合后的结果，二来也会根据上下文提供针对性的反馈。甚至可以通过自然语言描述直接帮你编码，“手动挡”变“自动挡”了。在 Vibe Coding 时，程序员就像司机，负责提供方向性的把控，让 AI 带你到达目的地。\n\n具体的使用心得\n1. 关于编码 最直接的功能就是帮你编码。目前的 AI 表现只能说是差强人意。它能帮你快速实现效果，但它似乎没系统学过“软件工程”。\n\n劣势区： 如果你只给它一个模糊的大概念，没有架构约束，它往往干不好，甚至会因为随意的修改破坏整体架构。\n\n优势区： 在细节上。只要给出详细的描述，AI 往往能符合你心意把代码写好。\n\n总结： 如果只给大方向，AI 可能会做过多发散修改，导致架构整体出错。\n\n\n2. 关于代码阅读 这是我觉得一个很不错的优势区间。可以结合 Issue&#x2F;Bug 快速了解项目。\n\n架构分析： AI 能帮你快速定位到相关代码块，指导你如何开始阅读，并解释代码的作用。\n\n快速上手： 不用费劲去翻找你需要哪部分代码，AI 可以帮你读出架构，助你快速上手。\n\n我的经验： 复制其他的项目到当前文件夹下，让 AI 分析代码，提取出解决思路和架构。\n\n\n3. 关于重构 重构代码时 AI 表现也不错，因为重构往往是琐碎的工作，很适合交给 AI 工具来解放双手。\n\n注意事项： 必须要结合《重构》的方法经验来，同时配合 Git，采用“小步快跑”的修复方式。不然 AI 意外破坏了架构可是很头痛的。\n\n4. 我的工作流 如果我要实现什么，通常会先用 AI 实现一个 Demo，然后利用 AI 小步重构代码，逐步完善。\n","tags":["分享","AI"]},{"title":"求职项目展示","url":"/2026/02/02/job-demo-showcase/","content":"视频如果加载有些慢可能是因为博客挂在github上，可以想办法加速下。\nSDL2 2D 平台跳跃游戏基于 SDL2 开发的 2D 游戏，C++实现物理，相机，图片等引擎功能模块，有限状态机切换界面。\n\n  \n  您的浏览器不支持播放该视频。\n\n\n项目源码\n\nUE 程序化生成几何体程序化生成几何体的Ue Demo。\n\n  \n  您的浏览器不支持播放该视频。\n\n\n\n项目源码\n","tags":["C++","游戏引擎","UE4"]},{"title":"可编辑曲面性能优化","url":"/2026/01/16/%E5%8F%AF%E7%BC%96%E8%BE%91%E6%9B%B2%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"之前的可编辑模型(如正方体，圆台）不涉及复杂的性能瓶颈，但是可编辑曲面不同。它的本质是沿着样条线（Spline）动态生成的拓扑结构，其顶点数量没有硬性上限，而是与路径长度、采样精度以及断面复杂度呈线性甚至几何级数增长。\n优化策略埋点分析与耗时监控“没有测量就没有优化。” 在盲目优化之前，必须知道瓶颈在哪。实现一个自定义的计时器类（Scoped Timer），在几何生成、碰撞构建等关键函数的入口进行埋点。\nstruct FScopedTimer&#123;    FString FunctionName;    double StartTime;    static int32 Depth;    FScopedTimer(FString InName)        : FunctionName(InName)    &#123;        StartTime = FPlatformTime::Seconds();        Depth++;    &#125;    ~FScopedTimer()    &#123;        double EndTime = FPlatformTime::Seconds();        float DurationMs = (float)((EndTime - StartTime) * 1000.0);        FString Indent = TEXT(&quot;&quot;);        for (int32 i = 1; i &lt; Depth; ++i)        &#123;            Indent += TEXT(&quot;  |  &quot;);        &#125;        FString LogLine = FString::Printf(TEXT(&quot;[%s] %s%s: %.4f ms\\n&quot;),            *FDateTime::Now().ToString(TEXT(&quot;%H:%M:%S.%s&quot;)),            *Indent,            *FunctionName,            DurationMs);        FString FilePath = FPaths::ProjectSavedDir() / TEXT(&quot;Profiling/SurfaceGenPerf.txt&quot;);        FFileHelper::SaveStringToFile(LogLine, *FilePath, FFileHelper::EEncodingOptions::AutoDetect, &amp;IFileManager::Get(), FILEWRITE_Append);        Depth--;    &#125;&#125;;int32 FScopedTimer::Depth = 0;\n\n内存管理：缓存复用与预分配C++ 中频繁的内存分配是非常昂贵的\n\n成员变量缓存： 将 LeftRailRaw, CachedRawPoints 等高频使用的数组提升为类的成员变量。每次生成时，调用 Reset() 而不是 Empty()。Reset() 会清空数据但保留 Capacity（容量），从而避免了底层的内存释放与重新分配。\n预分配 ： 在填充数据前，通过 CalculateVertexCountEstimate() 估算大概的顶点数，并调用 MeshData.Reserve()。这避免了 TArray 在 Add 过程中因为扩容而发生的多次数据搬迁。\n\n智能减面：基于角度的自适应采样并非所有的路段都需要同等密度的顶点采样。直线段仅需首尾两点确定，而弯道才需要高密度逼近。\n\n原理： 计算相邻线段方向向量的点积：$$\\vec{v_1} \\cdot \\vec{v_2} &#x3D; \\cos(\\theta)$$如果点积接近 1（例如 &gt; 0.9998），说明线段几乎共线，中间的顶点是冗余的，可以剔除。\n效果： 在不损失视觉质量的前提下，大幅减少了生成的三角形数量，进而减轻了 GPU 的光栅化压力。\n\n算法优化：空间哈希加速去环检测当曲面发生自我交叉（打结）时，我们需要检测并剔除这些几何体。朴素的去环检测需要 $O(N^2)$ 的暴力比对，顶点过多容易卡死线程。\n\n解决方案： 引入空间哈希 (Spatial Hashing)。\n\n实现： 我们将 3D 空间投影到 2D 网格，通过简单的位运算和大质数散射 ((X * 73856093) ^ (Y * 19349663)) &amp; (HashSize - 1) 将顶点映射到哈希桶中。之后会执行精确的 3D 欧氏距离检测。只要高度（Z轴）差距足够大，即便 2D 投影重叠，也绝不会被错误剔除。\n\n提升： 查询复杂度降至接近 $O(1)$，实现实时拖拽去环。\n\n\n","tags":["UE","C++","程序化网格体","COW"]},{"title":"可编辑模型实现写时复制","url":"/2026/01/03/%E5%8F%AF%E7%BC%96%E8%BE%91%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/","content":"什么是写时复制？直接复制这篇文章里的解释：“ 写入时复制（英语：Copy-on-write，简称COW）是一种计算机 [程序设计]领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。大概就是说：如果有多个相关的操作依赖同一个资源，如果其中一个需要修改，就在有修改时创建新的“存档”，其他的还是引用之前的“存档“。\n为什么可编辑模型要实现写时复制？这要从一个bug说起：可编辑模型保存为预设，如果场景中的模型修改参数，该修改也会影响预设的参数。 在修改场景中的模型时，因为场景中的物体和预设引用了同一个本地资源文件，，在创建预设时反序列化时解析文件时生成的模型相同。\n开始修bug。我首先在项目里发现了一个类似的资源，材质，都依赖本地文件。在用户确认修改场景中或者预设的材质后就会新建了一个文件。在没想起COW时，这对我来说就是一个很大的启发：创建新文件不就行了吗？\n何时创建新文件呢？因为可编辑模型在调整模型形状时没有确定按钮，何时创建本地文件的问题也困扰了我。最暴力的方式是每次变化就创建，但这样会创建许多没有用的文件，非常浪费。其实只需要每个模型对应的本地文件不同就行了。只需要一个判断标志，在第一次修改参数时创建一个新的本地文件，修改标志位。这样一个场景中的文件被报保存为预设或者预设在修改参数时，新旧物体之间会断开连接。\n","tags":["UE","C++","程序化网格体","COW"]},{"title":"2025年年终总结","url":"/2026/01/01/2025%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","content":"微信读书上今年的阅读时长是295h,比往年多一倍，跟年初我参加了一年期的微信会员阅读挑战有关。年度书籍是《白色巨塔》。我到后面完全得被剧情吸引，读玩之后有些唏嘘。主角一开始的设定我想起了一部动漫《monster》，主人公也同样是技术高明的外科医生。感兴趣可以看看。\n今年的年度游戏是博得之门3。我今年的游戏玩得比之前多，不过也算不上重度游戏玩家。博得之门3我106个小时一周目通关，体验确实对得起它的地位。\nbilibili的使用时间还是特别高，学习相关的占比最多。我个人还挺意外的，印象中我在bilibili上看娱乐视频特别多，难道是学习忘却了时间？\n上半年主要是在学校应付大三下学期的课，还有为求职做准备了。在今年3月份时我考虑好了我要做游戏引擎的工作，就陆续学习了相关课程。重刷了Games101，Games104，跟完The Cherno的C++，OpenGL，他的游戏引擎的课我跟了一半，之后找到实习就没看了。LeetCode我也刷到了600道题，在七月份找到工作后就没刷了。\n实习期间在公司做了什么呢？来公司我开始接触Ue4, 使用ProceduralMeshComponent生成自定义模型。在空闲时间跟完了Vulkan Toruaial，RayTracingInThreeWeek。能获得第一份实习，我自然是很开心的，我真的学到了许多东西。独自生活，和他人协作，学习成长，这半年的实习时光比我过去的大学生活都更有意义。\n大学期间省下的生活费换了一台新的笔记本电脑：机械革命蛟龙16；用实习的工资购买了几件数码产品：高驰pace3，Kindle Scribe2, Pico4 Ultra。新电脑用了半年了，没什么大问题。高驰的这款手表我本来是用于跑步的，不过实习期间晚上下班就有些不想出门了，现在它的主要是用于检测身体健康和充当闹钟，等之后恢复跑步习惯吧。原来的跑步习惯没了后，我的健康怎么保持呢？我就去买了VR头盔Pico4 Ultra。VR是一个我之前没接触的领域，体验了后感觉挺有意思的。现在就是通过VR增加运动量。\n今年我开了这个博客网站，可以算是写blog的第一年，虽然写blog的时候有些痛苦，但是每次发布的时候还挺开心的。我本来打算周更的，到现在变成了月更。虽然没人看，不过我还是希望我2026年能多些一些高质量的文章。\n写完上面的，发现自己还行，今年做了很多事，取得了自己的成就。\n\n关于2026年，还是许下几个新年愿望。\n\n顺利毕业;\n找到外企&#x2F;大厂的工作;\n提高自己的英语水平，达到雅思6.5;\n成为Godot的Contributor；\n\n","tags":["总结"]},{"title":"简历写作技巧","url":"/2025/12/21/%E7%AE%80%E5%8E%86%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/","content":"不要作假姓名、电话、邮箱必需。院校、专业、修读时间必需(实习&#x2F;工作经历，如果有的话）公司名称、职位、工作&#x2F;实习时间必需写在简历上的东西要百分百会\n可以结合STAR原则注：STAR原则，即Situation背景、Task任务、Action行动、Result产出。\n做了什么 + 成果（动宾+产出，避免口语时间（教育，实习等）由近到远\n一页纸简历在美国，人们会建议工作经验不足10年的求职者将简历压缩成1页；超过10年的，可以使用1.5至2页篇幅。\n如果成绩、各科成绩、四六级等等排名好分数高，可以写；否则就不要写，仅写拥有某项证书即可。写出参照物：gpa xxx 前xxx\n参考JD ，编辑经历 JD就是考纲。简历定制，不同行业，不同简历要和岗位相关\n照片按投递岗位要求和自身颜值酌情提供。如果要放一张照片，用证件照&#x2F;工作照\n个人评价一般不写，容易有凑字数嫌疑，如果一定要写建议转换为个人优势，简略写。如果提交电子版，建议PDF。邮件附件，以“xxx求职xxx岗位.pdf&#x2F;doc&#x2F;docx”命名\n可以有资格证书、技能、兴趣爱好、个人评价等内容，但最好和职位相关或是你个人亮点。\n邮件命名：姓名 + 岗位（可以 + 一句话）。正文信息按照标准邮件格式，可以补充很多信息例如对公司的了解 为什么想加入 你的优势等等。作品集可以用链接\n简历筛选的逻辑是反复打捞，想被看到就要勤刷新\n邮件主题，以“XXX求职&#x2F;应聘XXX职位”命名\n不使用第一人称。要避免使用第一人称 。除了求职意向这一部分需要第一人称外， 其他部分应该尽量使用第三人称。\n打开空白文档，事无巨细地把你这段时间实习中的一些成果、一些事情都记下来，先不管。然后从中提炼出实习经历。 问下是否能不被别人抄走，是否具体。是我的东西，我的特别的经历，无法被别人简单抄走。\n\n【个人经验】简历修改实战及面试建议_哔哩哔哩_bilibili最强简历攻略：简历制作技巧&#x2F;简历案例分析&#x2F;优秀简历展示&#x2F;热门简历问题答疑【框框的b站大学-简历攻略】_哔哩哔哩_bilibilibillryan&#x2F;resume at zh_CN大学生零经验必看！如何修改简历找第一份大厂实习？打破实习经验悖论？简历修改|实习渠道分享|大学生求职|大学生职业规划|产品经理|运营_哔哩哔哩_bilibili115.改了3份简历，总结了19条建议，你听听看，希望有用 - 轻刀快马 | 小宇宙 - 听播客，上小宇宙\n","tags":["简历"]},{"title":"困难问题下的简单解法","url":"/2025/11/29/%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E6%B3%95/","content":"以我遇到的自定义模型上的问题为例子。\n\n问题：这里创建了一个新的资源类型来供自定义模型使用。假设这个资源类型相当于是一根水管，资源类型的名称不可能包含具体的模型类型，管子只能识别一种类型的资源。现在我有五个自定义模型需要通过该水管，如何判断现在通过该水管的是哪个类型的。\n思路一：在使用该资源类型时同时使用一个参数。问题：不兼容原有的系统，维护麻烦。思路二：创建五根水管。费力，如果添加新类型就需要添加新的水管。\n解决方案： 创建子类类，继承父类，只改变其中一个模型类型的参数，问题解决。子类不用写什么，只需要基础父类，通过改一个参数的默认值来判断模型类型。\n\n问题：这里需要新建一个类，并且被识别为某特定类型的类。在这个系统里，如果一个类的同一父类的另一个子类被系统扫描先到，那么这个类就这会被识别为该类。\n思路一：去掉另一个子类。明明这个被去掉的类里什么也没有实现，并且没有任何地方使用到它，但是去掉之后就是有一个奇妙的bug，这就是老代码堆的魅力呀。思路二：在判断模型类型时对新增加的类做一个特殊判断。这个没有问题了，但是在那个判断类型的地方改代码，有性能问题，而且这样的硬编码对有代码洁癖的你来说完全不能接受。于情于理都要换新方法。\n解决方案：把可能会覆盖的类放在新增的类的后面。从物理或者说系统的意义上先识别你的类。\n\n让我想起了一本书，《你的灯亮着吗》。也许我现在在人生路上的疑惑，坎坷，有一个我没有意识到的简单解法也说不定。\n","tags":["C++","程序化网格体","ProceduralMeshComponent","思考"]},{"title":"序列化与反序列化：游戏存档背后的魔法","url":"/2025/10/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%83%8C%E5%90%8E%E7%9A%84%E9%AD%94%E6%B3%95/","content":"1. 核心概念：存档与读档的艺术序列化与反序列化是程序设计中实现数据持久化的核心机制，我们可以用 RPG 游戏的“存档”和“读档”来形象理解它们。\n1.1 序列化 (Serialization) ~ 存档序列化是将程序中复杂的内存对象（如自定义模型、类实例、角色状态等）转化为一种可存储或可传输的线性字节流的过程。\n\n目标： 将对象从瞬时的内存状态固化，以便存入文件或进行传输。\n\n1.2 反序列化 (Deserialization) ~ 读档反序列化是序列化的逆过程，它负责解析存储介质中的字节流，将其重新构建为程序能识别的内存对象，从而完整还原之前的状态。\n\n目标： 通过读取存储数据，重建运行时对象，恢复程序进度。\n\n\n2. 实战应用：在现有系统上添加新的本地资源我的需求是为自定义模型类型创建一个新的本地资源类型，目的是将模型的参数、类别等信息持久化到本地文件。由于这是一个本地功能（类似于一个 UE 插件的内部存储），且项目约定使用文本文件（如 JSON） 进行存储，因此我的工作重点是集成和扩展现有资源系统。\n2.1 现有序列化系统的运作流程（学习理解）通过参考同事的指导和已有的项目代码，我理解了一个成熟的资源加载系统通常遵循以下流程：\nA. 资源注册与系统启动\n\n特定目录扫描： 项目启动时，系统会遍历本地资源存储的默认目录。\n资源识别： 系统会读取文件，识别其资源类型和唯一标识符（通常是 GUID&#x2F;UUID）。\n系统注册： 所有资源类型必须预先在系统内完成注册，这是系统识别和处理新资源类型的前提。\n\nB. 反序列化入口与依赖加载\n\n反序列化入口： 任何需要加载的“场景”或“进度”（如 UE 的 Level 文件或存档文件）都充当反序列化的起始点。\n依赖引用： 这个入口文件并不存储所有资源的完整数据，而是存储了它所依赖的其他资源文件的 GUID。\n级联加载： 反序列化系统会自动读取这些 GUID，并触发相应资源的加载和反序列化，从而实现加载一个文件，还原一个完整对象集合的功能。\n\n2.2 在现有系统中添加新资源类型我的核心工作是在现有框架下添加支持我自定义模型的数据类型，并实现相应的读写逻辑：\n\n定义数据结构： 确定我的模型参数信息如何映射到项目约定的文本格式（例如 JSON 结构）。\n实现解析工具：\n序列化器 (Serializer)： 编写逻辑将内存中的模型对象写入到本地的资源文本文件中。\n反序列化器 (Deserializer)： 编写逻辑从资源文本文件中读取数据，并将其重建为内存中的模型对象。\n\n\n\n我的方法是参考项目中已经存在的资源类型实现，通过“模仿”和“扩展”来确保我的新资源类型能够被系统正确地注册和加载。\n","tags":["UE","C++","序列化"]},{"title":"自定义模型的法线和UV杂谈","url":"/2025/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B3%95%E7%BA%BF%E5%92%8CUV%E6%9D%82%E8%B0%88/","content":"法线法线是顶点的属性。与模型的光滑组（软硬边）有关。软边就让法线用相邻的面法线做插值，硬边就是同一个顶点上有多个相邻面的面法线。改法线是硬边或软边比较简单，如果是要实现特定的法线方向就没有这么简单了。\nUVUV 的范围是(0,0到1,1)要做的就是把所有的分配到UV空间里。模型的顶点对应在UV图里有一个UV坐标。在添加顶点的时候要确定顶点的3D空间的坐标和UV上的坐标。\nUV的生成与顶点有关，所以为了美术方便，在添加UV时需要考虑顶点的位置，所以我的BevelCube这个模型在后面就改过了生成的逻辑。就分为了主面和倒角面，倒角部分就不细分了。UV的本质是把顶点映射到UV平面上。给这个顶点指定一个UV图上的位置。\n也许在一开始就和美术对对UV比较好，这样可以对模型网格生成有帮助，少走弯路。\nUV是可以超过这个区域的（和我对接的美术说可以）；也可以重叠，比如正方体的六个面就放在这个 1 x 1 的区域完全重叠就好。\n\n仓库链接：ModenGen: Ue4使用ProceduralMeshComponent生成自定义模型。\n","tags":["程序化网格体","法线","UV"]},{"title":"ProceduralMesh转StaticMesh","url":"/2025/09/06/ProceduralMesh%E8%BD%ACStaticMesh/","content":"在ProceduralMeshComponent的细节面板上，有一个按键convert to static mesh，可以把你当前的PMC转换为静态模型。这个function的位置在ProceduralMeshComponentDetails.cpp，使用的是FStaticMeshSourceModel来构建。但是这个函数无法在运行时使用，因为有FStaticMeshSourceModel&amp; AddSourceModel();这个函数有WITH_EDITORONLY_DATA的宏限制。\n如果想在运行时把程序化模型转换为静态模型该怎么办呢？这就要使用FMeshDescription了。下面贴一段代码。\nUStaticMesh* AProceduralMeshActor::ConvertProceduralMeshToStaticMesh()&#123;    // 1. 验证输入参数    if (!ProceduralMeshComponent)    &#123;        return nullptr;    &#125;    const int32 NumSections = ProceduralMeshComponent-&gt;GetNumSections();    if (NumSections == 0)    &#123;        return nullptr;    &#125;    // 2. 创建一个临时的、只存在于内存中的UStaticMesh对象    UStaticMesh* StaticMesh = NewObject&lt;UStaticMesh&gt;(        GetTransientPackage(), NAME_None, RF_Public | RF_Standalone);    if (!StaticMesh)    &#123;        return nullptr;    &#125;    // 3. 创建并设置 FMeshDescription    FMeshDescription MeshDescription;    FStaticMeshAttributes Attributes(MeshDescription);    Attributes.Register();  // 这会注册包括材质槽名称在内的所有必要属性    // 获取对多边形组材质槽名称属性的引用，以便后续设置    // 这是将几何体与材质关联的关键    TPolygonGroupAttributesRef&lt;FName&gt; PolygonGroupMaterialSlotNames =        Attributes.GetPolygonGroupMaterialSlotNames();    FMeshDescriptionBuilder MeshDescBuilder;    MeshDescBuilder.SetMeshDescription(&amp;MeshDescription);    MeshDescBuilder.EnablePolyGroups();    MeshDescBuilder.SetNumUVLayers(1);    // 4. 从PMC数据填充 FMeshDescription    TMap&lt;FVector, FVertexID&gt; VertexMap;    for (int32 SectionIdx = 0; SectionIdx &lt; NumSections; ++SectionIdx)    &#123;        FProcMeshSection* SectionData =            ProceduralMeshComponent-&gt;GetProcMeshSection(SectionIdx);        if (!SectionData || SectionData-&gt;ProcVertexBuffer.Num() &lt; 3 ||            SectionData-&gt;ProcIndexBuffer.Num() &lt; 3)        &#123;            continue;        &#125;        // --- 开始材质设置修正 ---        // a. 为每个材质段创建一个唯一的槽名称        const FName MaterialSlotName =            FName(*FString::Printf(TEXT(&quot;MaterialSlot_%d&quot;), SectionIdx));        // b. 将材质和槽名称添加到StaticMesh的材质列表中        // 这会在最终的UStaticMesh上创建对应的材质槽        FStaticMaterial NewStaticMaterial(nullptr, MaterialSlotName);        // 初始化UV通道数据，避免ensure失败        NewStaticMaterial.UVChannelData.bInitialized = true;        NewStaticMaterial.UVChannelData.bOverrideDensities = false;        // 计算UV密度（基于实际的UV数据）        // 分析当前section的UV数据来计算合适的密度值        float UVDensity = 1.0f; // 默认密度        if (SectionData-&gt;ProcVertexBuffer.Num() &gt; 0)        &#123;            // 计算UV坐标的范围            FVector2D MinUV(FLT_MAX, FLT_MAX);            FVector2D MaxUV(-FLT_MAX, -FLT_MAX);            for (const FProcMeshVertex&amp; Vertex : SectionData-&gt;ProcVertexBuffer)            &#123;                MinUV.X = FMath::Min(MinUV.X, Vertex.UV0.X);                MinUV.Y = FMath::Min(MinUV.Y, Vertex.UV0.Y);                MaxUV.X = FMath::Max(MaxUV.X, Vertex.UV0.X);                MaxUV.Y = FMath::Max(MaxUV.Y, Vertex.UV0.Y);            &#125;            // 计算UV范围            FVector2D UVRange = MaxUV - MinUV;            if (UVRange.X &gt; 0.0f &amp;&amp; UVRange.Y &gt; 0.0f)            &#123;                // 基于UV范围计算密度，范围越大密度越小                UVDensity = FMath::Clamp(1.0f / FMath::Max(UVRange.X, UVRange.Y), 0.1f, 10.0f);            &#125;        &#125;        // 设置UV通道密度        for (int32 UVIndex = 0; UVIndex &lt; 4; ++UVIndex)        &#123;            NewStaticMaterial.UVChannelData.LocalUVDensities[UVIndex] = UVDensity;        &#125;        StaticMesh-&gt;StaticMaterials.Add(NewStaticMaterial);        // c. 在MeshDescription中为这个材质段创建一个新的多边形组        const FPolygonGroupID PolygonGroup = MeshDescBuilder.AppendPolygonGroup();        // d. 将多边形组与我们刚刚创建的材质槽名称关联起来        // 这是最关键的一步！        PolygonGroupMaterialSlotNames.Set(PolygonGroup, MaterialSlotName);        // --- 结束材质设置修正 ---        TArray&lt;FVertexInstanceID&gt; VertexInstanceIDs;        for (const FProcMeshVertex&amp; ProcVertex : SectionData-&gt;ProcVertexBuffer)        &#123;            FVertexID VertexID;            if (FVertexID* FoundID = VertexMap.Find(ProcVertex.Position))            &#123;                VertexID = *FoundID;            &#125;            else            &#123;                VertexID = MeshDescBuilder.AppendVertex(ProcVertex.Position);                VertexMap.Add(ProcVertex.Position, VertexID);            &#125;            FVertexInstanceID InstanceID = MeshDescBuilder.AppendInstance(VertexID);            MeshDescBuilder.SetInstanceNormal(InstanceID, ProcVertex.Normal);            MeshDescBuilder.SetInstanceUV(InstanceID, ProcVertex.UV0, 0);            MeshDescBuilder.SetInstanceColor(InstanceID, FVector4(ProcVertex.Color));            VertexInstanceIDs.Add(InstanceID);        &#125;        for (int32 i = 0; i &lt; SectionData-&gt;ProcIndexBuffer.Num(); i += 3) &#123;            if (i + 2 &gt;= SectionData-&gt;ProcIndexBuffer.Num()) &#123;                break;            &#125;            int32 Index1 = SectionData-&gt;ProcIndexBuffer[i + 0];            int32 Index2 = SectionData-&gt;ProcIndexBuffer[i + 1];            int32 Index3 = SectionData-&gt;ProcIndexBuffer[i + 2];            if (Index1 &gt;= VertexInstanceIDs.Num() ||                Index2 &gt;= VertexInstanceIDs.Num() ||                Index3 &gt;= VertexInstanceIDs.Num()) &#123;                continue;            &#125;            FVertexInstanceID V1 = VertexInstanceIDs[Index1];            FVertexInstanceID V2 = VertexInstanceIDs[Index2];            FVertexInstanceID V3 = VertexInstanceIDs[Index3];            // 将三角形添加到指定了材质信息的PolygonGroup中            MeshDescBuilder.AppendTriangle(V1, V2, V3, PolygonGroup);        &#125;    &#125;    if (MeshDescription.Vertices().Num() == 0) &#123;        return nullptr;    &#125;    // 7. 使用 FMeshDescription 构建 Static Mesh    TArray&lt;const FMeshDescription*&gt; MeshDescPtrs;    MeshDescPtrs.Emplace(&amp;MeshDescription);    UStaticMesh::FBuildMeshDescriptionsParams BuildParams;    BuildParams.bBuildSimpleCollision = true;  // StaticMesh默认开启碰撞    StaticMesh-&gt;BuildFromMeshDescriptions(MeshDescPtrs, BuildParams);    // 处理碰撞 - StaticMesh默认开启碰撞    &#123;        StaticMesh-&gt;CreateBodySetup();        UBodySetup* NewBodySetup = StaticMesh-&gt;BodySetup;        if (NewBodySetup)        &#123;            // 如果PMC有BodySetup，复制其碰撞数据            if (ProceduralMeshComponent-&gt;ProcMeshBodySetup)            &#123;                NewBodySetup-&gt;AggGeom.ConvexElems =                    ProceduralMeshComponent-&gt;ProcMeshBodySetup-&gt;AggGeom.ConvexElems;            &#125;            // 设置碰撞参数            NewBodySetup-&gt;bGenerateMirroredCollision = false;            NewBodySetup-&gt;bDoubleSidedGeometry = true;            NewBodySetup-&gt;CollisionTraceFlag = CTF_UseDefault;            // 创建物理网格            NewBodySetup-&gt;CreatePhysicsMeshes();        &#125;    &#125;    return StaticMesh;&#125;\n","tags":["UE","C++","程序化网格体","ProceduralMeshComponent"]},{"title":"实现倒角立方体","url":"/2025/08/16/%E5%AE%9E%E7%8E%B0%E5%80%92%E8%A7%92%E7%AB%8B%E6%96%B9%E4%BD%93/","content":"从平面到立体先实现是个普通的立方体。一个普通的立方体对大家来说想必难度不大，我们来实现一个倒角立方体。前面我们生成里了一个三角形，这次我们来做一个倒角立方体。\n实现基础立方体我们需要的参数只有一个\n\nCubeSize (立方体的尺寸)\n\n这个八个点我选择的是以原点（0,0,0）为中心的做法，使用HalfSize为每个点设置值。绘制的流程跟OpenGL类似，这里像是OpenGL的顶点数组。有图形学API的使用经验的，可以想想倒角的算法是怎样的。\nconst float HalfSize = CubeSize * 0.5f;TArray&lt;FVector&gt; CorePoints;CorePoints.Reserve(8);CorePoints.Add(FVector(-HalfSize, -HalfSize, -HalfSize));CorePoints.Add(FVector(HalfSize, -HalfSize, -HalfSize));CorePoints.Add(FVector(-HalfSize, HalfSize, -HalfSize));CorePoints.Add(FVector(HalfSize, HalfSize, -HalfSize));CorePoints.Add(FVector(-HalfSize, -HalfSize, HalfSize));CorePoints.Add(FVector(HalfSize, -HalfSize, HalfSize));CorePoints.Add(FVector(-HalfSize, HalfSize, HalfSize));CorePoints.Add(FVector(HalfSize, HalfSize, HalfSize));\n\n八个面，用16个三角形既可。生成面的方法是用两个三角形拼在一起组合为一个面。逆时针排序。\n// v0, v1, v2, v3 是按逆时针排列的四个顶点 AddTriangle(V0, V1, V2); AddTriangle(V0, V2, V3);\n\n这个立方体有两种倒角，边缘倒角和角落倒角。8个主面会向面的中心收缩，所以在就不能使用原始的点，要添加一个参数。\n\nBevelSize ：倒角的大小，不能大于半径 还有一个参数用来控制倒角的光滑度。\nBevelSegments ：倒角的面数\n\n边缘倒角通过对法线插值来计算下一条倒角边的两个顶点的位置，然后与前面的边相连形成一个倒角面。\nvoid FBevelCubeBuilder::GenerateEdgeBevels(const TArray&lt;FVector&gt;&amp; CorePoints)&#123;    // 边缘倒角定义结构    struct FEdgeBevelDef    &#123;        int32 Core1Idx;        int32 Core2Idx;        FVector Normal1;        FVector Normal2;    &#125;;    // 定义所有边缘的倒角数据    TArray&lt;FEdgeBevelDef&gt; EdgeDefs = &#123;        // +X 方向的边缘        &#123; 0, 1, FVector(0,-1,0), FVector(0,0,-1) &#125;,        &#123; 2, 3, FVector(0,0,-1), FVector(0,1,0) &#125;,        &#123; 4, 5, FVector(0,0,1), FVector(0,-1,0) &#125;,        &#123; 6, 7, FVector(0,1,0), FVector(0,0,1) &#125;,        // +Y 方向的边缘        &#123; 0, 2, FVector(0,0,-1), FVector(-1,0,0) &#125;,        &#123; 1, 3, FVector(1,0,0), FVector(0,0,-1) &#125;,        &#123; 4, 6, FVector(-1,0,0), FVector(0,0,1) &#125;,        &#123; 5, 7, FVector(0,0,1), FVector(1,0,0) &#125;,        // +Z 方向的边缘        &#123; 0, 4, FVector(-1,0,0), FVector(0,-1,0) &#125;,        &#123; 1, 5, FVector(0,-1,0), FVector(1,0,0) &#125;,        &#123; 2, 6, FVector(0,1,0), FVector(-1,0,0) &#125;,        &#123; 3, 7, FVector(1,0,0), FVector(0,1,0) &#125;    &#125;;    // 为每条边生成倒角    for (int32 EdgeIndex = 0; EdgeIndex &lt; EdgeDefs.Num(); ++EdgeIndex)    &#123;        const FEdgeBevelDef&amp; EdgeDef = EdgeDefs[EdgeIndex];               EdgeIndex, EdgeDef.Core1Idx, EdgeDef.Core2Idx);                GenerateEdgeStrip(CorePoints, EdgeDef.Core1Idx, EdgeDef.Core2Idx, EdgeDef.Normal1, EdgeDef.Normal2);                       EdgeIndex, MeshData.GetVertexCount());    &#125;               MeshData.GetVertexCount(), MeshData.GetTriangleCount());&#125;void FBevelCubeBuilder::GenerateEdgeStrip(const TArray&lt;FVector&gt;&amp; CorePoints, int32 Core1Idx, int32 Core2Idx,                                          const FVector&amp; Normal1, const FVector&amp; Normal2)&#123;           Core1Idx, Core2Idx);        TArray&lt;int32&gt; PrevStripStartIndices;    TArray&lt;int32&gt; PrevStripEndIndices;    for (int32 s = 0; s &lt;= Params.BevelSections; ++s)    &#123;        const float Alpha = static_cast&lt;float&gt;(s) / Params.BevelSections;        FVector CurrentNormal = FMath::Lerp(Normal1, Normal2, Alpha).GetSafeNormal();        FVector PosStart = CorePoints[Core1Idx] + CurrentNormal * Params.BevelSize;        FVector PosEnd = CorePoints[Core2Idx] + CurrentNormal * Params.BevelSize;        FVector2D UV1(Alpha, 0.0f);        FVector2D UV2(Alpha, 1.0f);        int32 VtxStart = GetOrAddVertex(PosStart, CurrentNormal, UV1);        int32 VtxEnd = GetOrAddVertex(PosEnd, CurrentNormal, UV2);        if (s &gt; 0 &amp;&amp; PrevStripStartIndices.Num() &gt; 0 &amp;&amp; PrevStripEndIndices.Num() &gt; 0)        &#123;            AddQuad(PrevStripStartIndices[0], PrevStripEndIndices[0], VtxEnd, VtxStart);        &#125;        PrevStripStartIndices = &#123; VtxStart &#125;;        PrevStripEndIndices = &#123; VtxEnd &#125;;    &#125;&#125;\n\n角落倒角思路一样，线换成了点，有三个方向的处理。\nvoid FBevelCubeBuilder::GenerateCornerBevels(const TArray&lt;FVector&gt;&amp; CorePoints)&#123;        if (CorePoints.Num() &lt; 8)    &#123;        UE_LOG(LogTemp, Error, TEXT(&quot;Invalid CorePoints array size. Expected 8 elements.&quot;));        return;    &#125;    // 为每个角落生成倒角    for (int32 CornerIndex = 0; CornerIndex &lt; 8; ++CornerIndex)    &#123;        const FVector&amp; CurrentCorePoint = CorePoints[CornerIndex];\t\t// 这里的四个需要反转渲染方向的倒角是我在实现实现中面的渲染方向反了的。\t\t//这里没有多调，也许用不同的连接方法可以更优雅一些。        bool bSpecialCornerRenderingOrder = (CornerIndex == 4 || CornerIndex == 7 || CornerIndex == 2 || CornerIndex == 1);        // 计算角落的轴向        const float SignX = FMath::Sign(CurrentCorePoint.X);        const float SignY = FMath::Sign(CurrentCorePoint.Y);        const float SignZ = FMath::Sign(CurrentCorePoint.Z);        const FVector AxisX(SignX, 0.0f, 0.0f);        const FVector AxisY(0.0f, SignY, 0.0f);        const FVector AxisZ(0.0f, 0.0f, SignZ);        // 创建顶点网格        TArray&lt;TArray&lt;int32&gt;&gt; CornerVerticesGrid;        CornerVerticesGrid.SetNum(Params.BevelSections + 1);        for (int32 Lat = 0; Lat &lt;= Params.BevelSections; ++Lat)        &#123;            CornerVerticesGrid[Lat].SetNum(Params.BevelSections + 1 - Lat);        &#125;        // 生成四分之一球体的顶点        for (int32 Lat = 0; Lat &lt;= Params.BevelSections; ++Lat)        &#123;            for (int32 Lon = 0; Lon &lt;= Params.BevelSections - Lat; ++Lon)            &#123;                const float LonAlpha = static_cast&lt;float&gt;(Lon) / Params.BevelSections;                const float LatAlpha = static_cast&lt;float&gt;(Lat) / Params.BevelSections;                TArray&lt;FVector&gt; Vertices = GenerateCornerVertices(CurrentCorePoint, AxisX, AxisY, AxisZ, Lat, Lon);                if (Vertices.Num() &gt; 0)                &#123;                    FVector CurrentNormal = (AxisX * (1.0f - LatAlpha - LonAlpha) +                        AxisY * LatAlpha +                        AxisZ * LonAlpha);                    CurrentNormal.Normalize();                    FVector2D UV(LonAlpha, LatAlpha);                    CornerVerticesGrid[Lat][Lon] = GetOrAddVertex(Vertices[0], CurrentNormal, UV);                &#125;            &#125;        &#125;        // 生成四分之一球体的三角形        for (int32 Lat = 0; Lat &lt; Params.BevelSections; ++Lat)        &#123;            for (int32 Lon = 0; Lon &lt; Params.BevelSections - Lat; ++Lon)            &#123;                GenerateCornerTriangles(CornerVerticesGrid, Lat, Lon, bSpecialCornerRenderingOrder);            &#125;        &#125;    &#125;    &#125;void FBevelCubeBuilder::GenerateCornerTriangles(const TArray&lt;TArray&lt;int32&gt;&gt;&amp; CornerVerticesGrid,                                                int32 Lat, int32 Lon, bool bSpecialOrder)&#123;    const int32 V00 = CornerVerticesGrid[Lat][Lon];    const int32 V10 = CornerVerticesGrid[Lat + 1][Lon];    const int32 V01 = CornerVerticesGrid[Lat][Lon + 1];    if (bSpecialOrder)    &#123;        AddTriangle(V00, V01, V10);    &#125;    else    &#123;        AddTriangle(V00, V10, V01);    &#125;    if (Lon + 1 &lt; CornerVerticesGrid[Lat + 1].Num())    &#123;        const int32 V11 = CornerVerticesGrid[Lat + 1][Lon + 1];        if (bSpecialOrder)        &#123;            AddTriangle(V10, V01, V11);        &#125;        else        &#123;            AddTriangle(V10, V11, V01);        &#125;    &#125;&#125;","tags":["UE","C++","程序化网格体","ProceduralMeshComponent"]},{"title":"在虚幻引擎中用代码生成网格体：基础入门","url":"/2025/08/02/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E4%BD%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","content":"今天我们来聊聊如何在虚幻引擎（Unreal Engine, UE）中用代码生成网格体。我发现网上关于这方面的介绍相对较少，而我刚好正在深入学习这个主题。本文是这个系列的第一篇，将带你了解基础知识。\n介绍 ProceduralMeshComponent 插件虚幻引擎提供了一个非常有用的插件，叫做 ProceduralMeshComponent。它允许我们通过编程的方式动态创建和修改网格体。这有什么用呢？对我来说，学习这个是为了实现自定义模型。比如，你可以通过UE的参数，在编辑器或运行时实时调整一个立方体的边长，而不需要预先导入一个静态模型。\n这个插件同时支持C++和蓝图，但我这里只介绍如何在C++中使用它。\n基础配置在开始编写代码之前，我们需要先配置项目以启用 ProceduralMeshComponent 插件。\n\n修改构建文件： 找到你项目目录下的 &lt;你的项目名&gt;.Build.cs 文件。\n\n添加插件依赖： 在 PublicDependencyModuleNames.AddRange 后面的花括号中，添加 &quot;ProceduralMeshComponent&quot;。修改后的代码应该类似这样：\n PublicDependencyModuleNames.AddRange(    new string[] &#123;        &quot;Core&quot;,        &quot;CoreUObject&quot;,        &quot;Engine&quot;,        &quot;InputCore&quot;,        &quot;ProceduralMeshComponent&quot; // 添加这一行    &#125;);\n\n重新生成项目文件： 关闭虚幻引擎项目。删除项目根目录下的 Binaries、Intermediate 和 Saved 文件夹。然后，右键点击你的 .uproject 文件，选择“Generate Visual Studio Project Files”（生成 Visual Studio 项目文件）。这会确保插件正确编译。\n\n\n使用 ProceduralMeshComponent配置完成后，我们就可以开始编写代码了。\n1. 包含头文件在你的C++文件中，需要包含 ProceduralMeshComponent 的头文件：\n#include &quot;ProceduralMeshComponent.h&quot;\n\n2. 创建一个Actor和组件首先，你需要创建一个继承自 AActor 的C++类。在这个Actor中，我们将添加一个 UProceduralMeshComponent 类型的指针成员变量。\n// MyProceduralMeshActor.h#pragma once#include &quot;CoreMinimal.h&quot;#include &quot;GameFramework/Actor.h&quot;#include &quot;ProceduralMeshComponent.h&quot;#include &quot;MyProceduralMeshActor.generated.h&quot;UCLASS()class MYPROJECT_API AMyProceduralMeshActor : public AActor&#123;    GENERATED_BODY()public:    AMyProceduralMeshActor();    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = &quot;Components&quot;)    UProceduralMeshComponent* ProceduralMesh;protected:    virtual void BeginPlay() override;public:    void GenerateMesh(); // 用于生成网格体的方法&#125;;\n\n然后在 .cpp 文件中初始化组件：\n// MyProceduralMeshActor.cpp#include &quot;MyProceduralMeshActor.h&quot;AMyProceduralMeshActor::AMyProceduralMeshActor()&#123;    PrimaryActorTick.bCanEverTick = false;    // 创建并设置ProceduralMeshComponent    ProceduralMesh = CreateDefaultSubobject&lt;UProceduralMeshComponent&gt;(TEXT(&quot;GeneratedMesh&quot;));    RootComponent = ProceduralMesh; // 将其设置为根组件&#125;void AMyProceduralMeshActor::BeginPlay()&#123;    Super::BeginPlay();    GenerateMesh(); // 在Actor开始时生成网格&#125;\n\n3. 理解核心函数：CreateMeshSection_LinearColorProceduralMeshComponent 提供了几个用于创建网格体的函数，它们的工作方式都非常相似。这里我们重点介绍一个最常用的函数：CreateMeshSection_LinearColor。\n函数声明：\nvoid CreateMeshSection_LinearColor(int32 SectionIndex,                                   const TArray&lt;FVector&gt;&amp; Vertices,                                   const TArray&lt;int32&gt;&amp; Triangles,                                   const TArray&lt;FVector&gt;&amp; Normals,                                   const TArray&lt;FVector2D&gt;&amp; UV0,                                   const TArray&lt;FLinearColor&gt;&amp; VertexColors,                                   const TArray&lt;FProcMeshTangent&gt;&amp; Tangents,                                   bool bCreateCollision,                                   bool bSRGBConversion = false);\n\n这个函数的工作原理类似于 OpenGL 等图形编程中构建几何体的方法。你通过定义一系列的顶点（Vertices）、三角形索引（Triangles），以及可选的法线（Normals）、UV坐标（UVs） 和顶点颜色（VertexColors） 来构建网格体。\n4. 示例：生成一个简单的平面让我们在 GenerateMesh 方法中实现一个简单的平面：\n// MyProceduralMeshActor.cppvoid AMyProceduralMeshActor::GenerateMesh()&#123;    TArray&lt;FVector&gt; Vertices;    TArray&lt;int32&gt; Triangles;    TArray&lt;FVector&gt; Normals;    TArray&lt;FVector2D&gt; UV0;    TArray&lt;FLinearColor&gt; VertexColors;    TArray&lt;FProcMeshTangent&gt; Tangents;    // 1. 定义顶点    Vertices.Add(FVector(0, 0, 0));      // 索引 0    Vertices.Add(FVector(100, 0, 0));    // 索引 1    Vertices.Add(FVector(0, 100, 0));    // 索引 2    Vertices.Add(FVector(100, 100, 0));  // 索引 3    // 2. 定义三角形（逆时针顺序为正面）    Triangles.Add(0); // 第一个三角形    Triangles.Add(1);    Triangles.Add(2);    Triangles.Add(1); // 第二个三角形    Triangles.Add(3);    Triangles.Add(2);    // 3. 定义法线（所有顶点朝向 Z 轴正方向）    Normals.Add(FVector(0, 0, 1));    Normals.Add(FVector(0, 0, 1));    Normals.Add(FVector(0, 0, 1));    Normals.Add(FVector(0, 0, 1));    // 4. 定义UV坐标    UV0.Add(FVector2D(0, 0));    UV0.Add(FVector2D(1, 0));    UV0.Add(FVector2D(0, 1));    UV0.Add(FVector2D(1, 1));    // 5. 定义顶点颜色（白色）    VertexColors.Add(FLinearColor(1, 1, 1, 1));    VertexColors.Add(FLinearColor(1, 1, 1, 1));    VertexColors.Add(FLinearColor(1, 1, 1, 1));    VertexColors.Add(FLinearColor(1, 1, 1, 1));    // 6. 调用创建函数    ProceduralMesh-&gt;CreateMeshSection_LinearColor(        0,              // SectionIndex        Vertices,        Triangles,        Normals,        UV0,        VertexColors,        Tangents,       // 暂不使用切线        true            // 创建碰撞    );&#125;\n\n将 AMyProceduralMeshActor 拖拽到场景中，运行游戏，你就会看到一个由代码生成的白色平面！\n在编辑器中调试和预览（可选）为了方便在不运行游戏的情况下，实时预览参数对网格体的影响，我们可以利用虚幻编辑器中的 PostEditChangeProperty 函数。\n首先，在你的 .h 文件中，添加以下代码：\n// MyProceduralMeshActor.h#if WITH_EDITOR// 在编辑器中属性改变时调用virtual void PostEditChangeProperty(FPropertyChangedEvent&amp; PropertyChangedEvent) override;#endif\n\n然后，在 .cpp 文件中实现该函数。这里以一个虚构的 CubeParameters 结构体为例，你可以根据自己的项目需求进行修改：\n// MyProceduralMeshActor.cpp#if WITH_EDITORvoid AMyProceduralMeshActor::PostEditChangeProperty(FPropertyChangedEvent&amp; PropertyChangedEvent)&#123;    Super::PostEditChangeProperty(PropertyChangedEvent);    // 检查是否是需要实时预览的属性被修改    if (PropertyChangedEvent.Property != nullptr)    &#123;        FName PropertyName = PropertyChangedEvent.Property-&gt;GetFName();        if (PropertyName == GET_MEMBER_NAME_CHECKED(FCubeParameters, CubeSize) ||            PropertyName == GET_MEMBER_NAME_CHECKED(FCubeParameters, SegmentCount))        &#123;            // 当相关属性改变时，重新生成网格体            GenerateMesh();        &#125;    &#125;&#125;#endif\n\n这段代码利用了虚幻引擎的反射系统，它只在编辑器中编译和运行（由 #if WITH_EDITOR 宏控制）。每当你在 Actor 的 Details 面板中修改了特定属性，它就会自动调用 GenerateMesh 函数，让你即时看到变化。\n接下来这次我们只是简单介绍了 ProceduralMeshComponent 的基础用法。在下一篇文章中，我将深入讲解如何利用这些知识，一步步实现一个带有倒角（Bevel）效果的立方体。\n","tags":["UE","C++","程序化网格体","ProceduralMeshComponent"]},{"title":"哲学和心理学书籍推荐","url":"/2025/07/12/%E5%93%B2%E5%AD%A6%E5%92%8C%E5%BF%83%E7%90%86%E5%AD%A6%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/","content":"哲学哲学通识课：《苏菲的世界》\n我个人比较喜欢斯多葛主义，下面列出我看过的相关书籍：\n\n《人生的智慧》\n《活出生命的意义》\n《斯多葛生活哲学》\n《沉思录》\n《像哲学家一样生活》\n《障碍是道路》可以在这个斯多葛主义书单可以看看还有什么其它书。\n\n心理学这个和脑科学或者其他概念我不太好划分，有些可以放在其他分类里。这里就推这些吧。\n《活出生命的意义》《少有人走的路》《改变的历程》《心理控制方法》《思考致富》《论人的成长》\n","tags":["分享","书籍"]},{"title":"MIT 6.S081 Operating System Engineering Lab2 system calls","url":"/2025/07/03/MIT-6-S081-Operating-System-Engineering-Lab2-system-calls/","content":"注册系统call在以下文件里添加代码\n// user/usys.plentry(&quot;trace&quot;);\n\n // user/user.h int trace(int);\n// kernel/syscall.h.#define SYS_trace  22\n\n// syscall.cextern uint64 sys_trace(void);static uint64 (*syscalls[])(void) = &#123;// ...[SYS_trace]   sys_trace, // add this line&#125;;\n\n\n\nSystem call tracing// proc.hstruct proc &#123;  int mask; //for tracing&#125;;\n\n// syscall.cconst char *syscall_names[] = &#123;&quot;placeholder&quot;, &quot;fork&quot;, &quot;exit&quot;, &quot;wait&quot;, &quot;pipe&quot;, &quot;read&quot;, &quot;kill&quot;, &quot;exec&quot;, &quot;fstat&quot;, &quot;chdir&quot;,&quot;dup&quot;, &quot;getpid&quot;, &quot;sbrk&quot;, &quot;sleep&quot;, &quot;uptime&quot;, &quot;open&quot;, &quot;write&quot;, &quot;mknod&quot;,&quot;unlink&quot;, &quot;link&quot;, &quot;mkdir&quot;, &quot;close&quot;, &quot;trace&quot;, &quot;sysinfo&quot;,&#125;;voidsyscall(void)&#123;  int num;  struct proc *p = myproc();  num = p-&gt;trapframe-&gt;a7;  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;    p-&gt;trapframe-&gt;a0 = syscalls[num]();      if ((p-&gt;mask &gt;&gt; num) &amp; 1)          printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);  &#125; else &#123;    printf(&quot;%d %s: unknown sys call %d\\n&quot;,            p-&gt;pid, p-&gt;name, num);    p-&gt;trapframe-&gt;a0 = -1;  &#125;&#125;\n\n// kernel/proc.cintfork(void)&#123;// ...  np-&gt;mask = p-&gt;mask; // copy mask from parent to child// ...&#125;\n\n// sysproc.cuint64 sys_trace(void)&#123;    int mask;    if(argint(0, &amp;mask) &lt; 0)        return -1;    struct proc *p = myproc();    p-&gt;mask |= mask;    return 0;&#125;\n\n\nSysinfo// proc.cuint64 countproc(void)&#123;  struct proc *p;  int count = 0;  for(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;        if (p-&gt;state != UNUSED)            count++;  &#125;  return count;&#125;\n\n// kalloc.cuint64 kfreemem(void)&#123;    struct run *r;    uint64 total = 0;     acquire(&amp;kmem.lock);    for (r = kmem.freelist; r; r = r-&gt;next)        total += PGSIZE;    release(&amp;kmem.lock);    return total;&#125;\n\n// sysproc.cuint64 sys_sysinfo(void)&#123;  struct sysinfo info;  uint64 addr;  if (argaddr(0, &amp;addr) &lt; 0)        return -1;  info.freemem = kfreemem();  info.nproc = countproc();    struct proc *p = myproc();  if(copyout(p-&gt;pagetable, addr, (char *)&amp;info, sizeof(info)) &lt; 0)      return -1;    return 0;&#125;","tags":["操作系统","6.S081"]},{"title":"MIT 6.S081 Operating System Engineering Lab1 Xv6 and Unix utilities","url":"/2025/06/27/MIT-6-S081-Operating-System-Engineering-Lab1-Xv6-and-Unix-utilities/","content":"sleep这个挺简单的，先给大家自信。\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123;    if (argc != 2) &#123;        printf(&quot;sleep error: just need one argument. \\n&quot;);        exit(1);    &#125;    sleep(atoi(argv[1]));    exit(0);&#125;\n\n\npingpong这里fork之后，父子进程就有了相同的管道的文件描述符。\n父进程先写入字符，然后等待子进程处理后接收传回来的字符。\n#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123;    char buf[1];    int n;    int status;    int fds[2];    pipe(fds);    int pid = fork();    if (pid == 0) &#123;        n = read(fds[0], buf, sizeof(buf));        printf(&quot;%d: received ping\\n&quot;, getpid());        write(fds[1], buf, n);    &#125; else &#123;        write(fds[1], &quot;p&quot;, 1);        wait(&amp;status);        n = read(fds[0], buf, sizeof(buf));        printf(&quot;%d: received pong\\n&quot;, getpid());    &#125;    exit(0);&#125;\n\n\nprimes网站上给的论文Bell Labs and CSP Threads很好得说明了原理。我先没有用fork，只用pipe模拟了这个sieve。因为无法确定终止的循环数，而且网站上提示用递归，所以用迭代做这题是合理的。\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;void sieve(int read_fd) &#123;    int p;    char buf[1];    if (read(read_fd, buf, 1) == 0) &#123;        close(read_fd);        exit(0);    &#125;    p = buf[0];    printf(&quot;prime %d\\n&quot;, p);        int fds[2];    pipe(fds);    if (fork() == 0) &#123;        close(fds[1]);        sieve(fds[0]);        exit(0);    &#125; else &#123;        close(fds[0]);        while (read(read_fd, buf, 1)) &#123;            if (buf[0] % p != 0) &#123;                write(fds[1], buf, 1);            &#125;        &#125;    &#125;    close(read_fd);    close(fds[1]);    wait(0);    exit(0);&#125;int main(int argc, char *argv[])&#123;    int fds[2];    pipe(fds);    for (int i = 2; i &lt;= 35; i++) &#123;        write(fds[1], &amp;i, 1);    &#125;    close(fds[1]);    sieve(fds[0]);    exit(0);&#125;\n\n\nfind这个参考了ls.c。c语言的字符串处理是这里较难的部分。\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;char* getname(char *path)&#123;    char *p;    for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != &#x27;/&#x27;; p--)        ;    p++;    return p;&#125;void find(char *path, char *target)&#123;    if (strcmp(target, &quot;.&quot;) == 0) &#123;        exit(0);    &#125;    if (strcmp(target, &quot;..&quot;) == 0) &#123;        exit(0);    &#125;    char buf[512], *p;    int fd;    struct dirent de;    struct stat st;    if((fd = open(path, 0)) &lt; 0)&#123;        fprintf(2, &quot;find: cannot open %s\\n&quot;, path);        return;    &#125;    if(fstat(fd, &amp;st) &lt; 0)&#123;        fprintf(2, &quot;find: cannot stat %s\\n&quot;, path);        close(fd);        return;    &#125;    switch (st.type) &#123;        case T_FILE:            if (strcmp(getname(path), target) == 0) &#123;                printf(&quot;%s\\n&quot;, getname(buf));            &#125;            break;        case T_DIR:            if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) &#123;                printf(&quot;find: path too long\\n&quot;);                break;            &#125;            strcpy(buf, path);            p = buf+strlen(buf);            *p++ = &#x27;/&#x27;;            while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) &#123;                if(de.inum == 0)                    continue;                memmove(p, de.name, DIRSIZ);                p[DIRSIZ] = 0;                if(stat(buf, &amp;st) &lt; 0)&#123;                    printf(&quot;find: cannot stat %s\\n&quot;, buf);                    continue;                &#125;                char fname[DIRSIZ+1];                memmove(fname, de.name, DIRSIZ);                fname[DIRSIZ] = 0;                if (strcmp(fname, &quot;.&quot;) == 0) &#123;                    continue;                &#125;                if (strcmp(fname, &quot;..&quot;) == 0) &#123;                    continue;                &#125;                char cpath[512];                int path_len = strlen(path);                memmove(cpath, path, path_len);                cpath[path_len] = &#x27;/&#x27;;                memmove(cpath + path_len + 1, fname, strlen(fname));                cpath[path_len + 1 + strlen(fname)] = 0;                if (st.type == T_DIR) &#123;                    find(cpath, target);                &#125; else if (st.type == T_FILE) &#123;                    if (strcmp(fname, target) == 0) &#123;                        printf(&quot;%s/&quot;, path);                        printf(&quot;%s\\n&quot;, fname);                    &#125;                &#125;            &#125;            break;    &#125;    close(fd);&#125;int main(int argc, char *argv[])&#123;    if (argc == 1) &#123;        printf(&quot;find error: too few parameters!\\n&quot;);        exit(1);    &#125;    if (argc &gt; 3) &#123;        printf(&quot;find error: too many parameters!\\n&quot;);        exit(1);    &#125;    if(argc == 2)&#123;        find(&quot;.&quot;, argv[1]);        exit(0);    &#125;    find(argv[1], argv[2]);    exit(0);&#125;\n\n\nxargs我之前都没有用过这个命令，看这篇文章了解了它的功能，感觉挺好用的。\n这里的思路简单，就是先把argv和管道运算符 | 传来的参数放在一个数组里，再用fork和exec执行。前面的处理有几点要注意：\n\n|传来的参数要从0 描述符里读取；\n新数组要排除argv[0]，不然可能递归调用xargs；\n从示例可知，xargs之后的参数要与前面的每一行拼接运行。\n\n没有写 -n 参数，评分系统也过了，不过要写也能写。\n#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;char* readline() &#123;    char* buf = malloc(100);    if (!buf) &#123;        return 0;    &#125;    char* p = buf;    while (read(0, p, 1) == 1) &#123;        if (*p == &#x27;\\n&#x27; || *p == 0) &#123;            *p = 0;            return buf;        &#125;        p++;    &#125;    if (p != buf) &#123;        *p = 0;        return buf;    &#125;    free(buf);    return 0;&#125;int main(int argc, char *argv[])&#123;    if (argc &lt; 2) &#123;        printf(&quot;Usage: xargs command&quot;);        exit(1);    &#125;        char* arr[MAXARG];    char* line;    while ((line = readline()) != 0) &#123;        int arr_index = 0;        for (int i = 1; i &lt; argc; i++) &#123;            arr[arr_index++] = argv[i];        &#125;        char* p = line;        while (*p) &#123;            while (*p == &#x27; &#x27;) p++;            if (*p == 0) break;            char* start = p;            while (*p &amp;&amp; *p != &#x27; &#x27;) p++;            int len = p - start;            char* arg = malloc(len + 1);            if (!arg) &#123;                printf(&quot;malloc failed\\n&quot;);                exit(1);            &#125;            for (int i = 0; i &lt; len; i++) &#123;                arg[i] = start[i];            &#125;            arg[len] = 0;            arr[arr_index++] = arg;            if (arr_index &gt;= MAXARG - 1) break;        &#125;        arr[arr_index] = 0;        int pid = fork();        if (pid == 0) &#123;            exec(arr[0], arr);            printf(&quot;exec failed!\\n&quot;);            exit(1);        &#125; else &#123;            wait((int *)0);        &#125;        for (int i = argc - 1; i &lt; arr_index; i++) &#123;            free(arr[i]);        &#125;        free(line);    &#125;    exit(0);&#125;\n\n\n写起来还蛮有意思的。\n\nReferenceMIT 6.S081: Operating System Engineering - CS自学指南\n","tags":["操作系统","6.S081"]},{"title":"新电脑配置指南","url":"/2025/06/16/%E6%96%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","content":"一、基础设置\n用户名设置系统激活注册时建议使用英文用户名。某些开发工具对路径兼容性较差，含中文可能导致异常。\n\n语言与界面优化  \n\n添加英文语言包，方便中英文切换。  \n在任务栏设置中关闭“小组件”和“任务视图”，并隐藏搜索框，让界面更简洁清爽。\n\n\n系统优化  \n\n将桌面路径迁移到 D 盘（或任意非 C 盘路径），减轻系统盘压力。  \n打开以管理员身份运行的 PowerShell，执行以下命令关闭休眠功能，进一步节省 C 盘空间：  powercfg -h off\n\n个人观点：Windows 的休眠功能并不理想，平时直接关机更为稳妥。\n\n\n\n\n安全策略调整在微软电脑管家（Microsoft PC Manager）中，将除 C 盘以外的所有磁盘添加为“信任磁盘”或“排除项”，避免开发时频繁弹出安全提示。\n\n\n\n二、D 盘目录结构为了避免路径问题，所有文件夹名使用英文，并统一集中管理：\n\nBrowserDownload：浏览器下载目录\nCaden：我的英文名，放一些临时文件或杂项  \nCode：各类项目代码存放地  \nNetworkDiskAndBtDownload：网盘及 BT 下载文件存储  \nRepositories：存放从 GitHub 克隆下来的仓库  \nSoftware：软件下载目录\n\n\n三、软件安装与配置浏览器\n安装 Google Chrome，并将其和系统自带的 Microsoft Edge 的默认下载路径设置为 D:\\BrowserDownload。\n\n开发工具\nGit\nFork：Git 图形界面工具\nPowerShell：推荐配合 [Oh My Posh] 美化终端\nWatt Toolkit：可用于 GitHub 下载加速\n\n输入法与语言工具\n小狼毫输入法配置 雾凇拼音，并使用小鹤双拼方案\n欧陆词典：好用的英文词典\nPixPin：截图标注工具，开源且好用\n\n\n可以移步到这篇 推荐博客。\n\n\n四、数据迁移建议\n浏览器数据：登录账号同步书签和插件即可。\n项目代码 &#x2F; 配置文件：使用 Git 进行云端同步，方便管理。\n敏感或私密数据：不建议上传云盘，可通过 U 盘或局域网方式传输。\n\n\n如果你有什么建议，欢迎在评论区留言交流！\n","categories":["经验分享"],"tags":["Windows"]},{"title":"《废都物语》游玩体验","url":"/2025/06/09/%E3%80%8A%E5%BA%9F%E9%83%BD%E7%89%A9%E8%AF%AD%E3%80%8B%E6%B8%B8%E7%8E%A9%E4%BD%93%E9%AA%8C/","content":"尽量不剧透。\n\n这个游戏剧情融合了各种神话，虚构了一个丰富的大河世界。主角有四个出身可以选，四个出身的线大体相同，但又有各自独特的剧情，每条线各自揭开了部分剧情的谜底。可以在酒馆里集结队友，踏上旅途，像跑团。游戏内有多名队友，陪你冒险，都有着独特的个性，喜欢某位角色可以一直带着，可能会解锁队友个人的独特剧情。在游戏过程中也有挺恶搞的地方，比如睡美人、怪仙，夜种王，也许会让你心领神会，忍俊不禁。\n个人是按盗贼-&gt;骑士-&gt;法师-&gt;贤者的顺序玩了共计四周目，并不是那种多周目大佬。游戏难度我选的普通，因为游戏的的多周目有继承机制，所以在我玩的周目里最难的是第一周目的盗贼出身。身板脆，不知道隐藏宝箱在哪里，对地图多大和谜题没有底，完全对世界陌生，这是我开荒的体验。\n挺过初期的困难后就渐渐被玩法和剧情吸引了。 作为一个宝可梦爱好者，对西方奇幻和跑团也颇有兴趣的人，这个经典RPG战斗，那些非战斗的技能和以前宝可梦里的秘传技能等在战斗外的地方也可以使用的技能类似，龙与地下城式的队友集结和地图探险，不错。但是剧情就没有仔细看，以至于有的地方卡关查攻略了。不过这样也可以，我本来玩的时候也没有想着剧情会多优秀，到了后面几周目才渐渐琢磨出味道来，之后看了别人剧情梳理我才对剧情有一个完整的概念。\n本来第一周目打得我都快弃坑了，不经意间在一次回档的时候没有选择打死龙蛋而是试着给它命名，结果孵出来了一个龙女，虽然这剧情有些熟悉但是我喜欢。想想这我之前不就算是错过了吗，鬼使神差让我读了一个前一点的档，出来一个龙女儿，这我得带着她通关呀。就继续打了，之后渐渐喜欢上了这个游戏。\n游玩体验最好的是第四周目，打最终boss时，主角是贤者防御高，先给队友加攻加防，然后一直放回复技能就行，输出就靠队友，无脑点威力最高的技能。\n别被画风劝退了，挺不错的。或者也可以等等重置版。\n","tags":["游戏"]},{"title":"游戏引擎学习之旅（4）批渲染和调试","url":"/2025/06/08/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%884%EF%BC%89%E6%89%B9%E6%B8%B2%E6%9F%93%E5%92%8C%E8%B0%83%E8%AF%95/","content":"上次博客之后，先是抽象出了一个Renderer2D的类。这个类调用了是Renderer部分其他的代码，不知道OpenGL或者其他图形学API的具体实现如何。这样用户使用的时候只需要调用提供的静态函数就行了，图形学API是不影响用户写好的代码，是一个相当清晰的不错的设计。\n 接下来就是在这个已经使用可以工作的Rednerer2D类里实现批渲染（Batch Rendering）。\n 我对批渲染很有好感，这个得加进引擎里。之前用SDL2画地牢的地图时，我试着在更新初始化地图值时把绘制命令放在了for循环，导致每添加到一个图片到SDL_surface里就会调用一次绘制命令。这样地图绘制时是从上往下一点一点渲染，花了一百多秒完成。之后把绘制命令拿出for循环，这样就是在等Surface一次更新完后在绘制，地图一瞬间就绘制好了。\n实现批渲染的方法。之前的实现是用一个数组存储，把位置纹理坐标等放在起，每个图形都是单独的一个数组，现在把数组改成结构体，不同的成员变量对应了不同属性，更新的值会插入在一个数组里。另有一个结构体来管理各种数值，前面的和纹理数组都在这个里面当成为变量。声明上述为一个静态结构体，每次调用是设置的数值等都在这里设置，这样在绘制的时候只使用结构体里的一个索引数组，渲染是就把前面的整个当成是一个图形绘制。\n不过在添加纹理的时候出了一个Bug。我只绘制纯颜色块时正确，绘制带纹理的方块时候就是黑的，没有渲染出纹理，而本该是纯颜色的方块却有渲染出了纹理。\n那就开始Debug吧。我先是查看代码，看了最近两次提交代码的修改部分，没发现问题。然后对这个错误进行测试，发现当绘制多个带纹理的方块时，本该是纯颜色的方块会渲染出最后一个绑定的纹理。问题出在了纹理设置上。当我在纹理渲染的函数里手动把slot 修改为0.0f时，渲染出了该有给的纹理，把slot设为没有纹理的绑定的值（比如3）就会变成默认的白色，说明这是纹理slot绑定出的问题。然后我找到了纹理绑定的那段代码，传了slot值（不指定就是默认复制的0），功能正常。\n我有些震惊与这样的错误。我现在学习这个引擎的方式的流程如下。\n\n看一遍视频，了解本次代码该实现的效果；\n点开GitHub对应提交的代码提交，理解代码的设计和实现；\n编写代码；\n改错；\n提交到GitHub仓库。\n\n我再次看视频发现视频里是有传入参数的，所以这个提交的代码就没有达成视频里的功能。我默认认为代码要测试无误才提交，也相信这个是对的。但是TheCherno这个大牛居然在提交的时候没有注意到这个。\n也许TheCherno是想提醒我要多思考，不要光剽窃代码。想告诉我大牛也会有不小心的时候，想说我也可以成为大牛。\n谢谢你，TheCherno！\n","tags":["游戏引擎"]},{"title":"代码之外的推荐","url":"/2025/06/02/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E6%8E%A8%E8%8D%90/","content":"浏览器插件\nOneTab：压缩页面，减少内存占用，方便搜集临时的不想收藏的页面，配合浏览器的分组功能效果更佳；\n沙拉查词：聚合词典划词翻译；\nuBlacklist：屏蔽网站用，清理 [内容农场]；\nGet RSS Feed URL：获取当前网页的RSS订阅；\n微信读书笔记助手：复制网页版微信读书画线评论；\nImmersive Translate：内嵌式网页翻译；\nMarinara: Pomodoro® Assistant：一个番茄工作法的番茄钟；\nGlobal Speed: 视频速度控制 - Microsoft Edge Addons：视频速度控制。\n\nWindows工具\nSumatra PDF：功能强大的电子书阅读器，可以打开多种电子书格式；\n小狼毫输入法：好用的输入法软件；\nKeePass：密码管理工具；\nGeek：知名卸载工具；\nQbittorrent：磁力下载软件，配合资源下载网址海盗湾使用；\nSpaceSniffer：磁盘空间分析软件；\nqimgv：图片浏览器：觉得Windows自带的图片显示不好用，可以试试这个；\nPixPin：截图贴图工具；\nPotPlayer：可能是最好用的视频播放器；\nWox：调用了Everything的软件快速启动器；\nObsidian：markdown笔记软件我选的这个，免费，双链笔记功能强大，推荐配合常青笔记，下载插件能让软件更好用；\nWatt Toolkit：加速器，连接 Github 和 Steam；\n爱传送：手机和电脑跨平台传送文件；\nLibreOffice：Wps和Micro Office的开源平替；\nGIMP：Adobe Photoshop 的开源平替；\n网易UU远程：远程控制电脑；\nOBS：开源视频录制软件；\nFork：Git 图形界面工具；\nCubox：跨平台浏览器页面管理；\nFluent Reader：rss阅读器；\nTwinkle Tray：一个软件控制多个屏幕亮度；\nf.lux: 护眼工具；\n7Zip：开源压缩软件。\n\n安卓App在应用商店、github或者浏览器上能找到：\n\nLibrera：阅读软件，可以打开Txt，PDF，Mobi等各种格式的文件；\n微信读书：电子书书城，阅读购买电子书；\nflomo：有浏览器页面，互传文字挺方便。\nHabitica：游戏化任务管理。\n小宇宙：听播客；\nZArchiver&#x2F;MT Manager：手机文件管理，压缩包解压；\n\n推荐学习的技能\n双拼练习：一种打字拼音输入法，有多种映射方式，选一种即可；\nMarkdown：轻量级的标记语言，方便排版，写笔记，博客文章用；\nLatex：一种编程语言，方便排版，写论文用。\n\n","tags":["分享"]},{"title":"《重构 改善既有代码的设计》简评","url":"/2025/05/29/%E3%80%8A%E9%87%8D%E6%9E%84%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AE%80%E8%AF%84/","content":"读本书的缘由看这里：游戏引擎学习之旅（2）渲染器重构。\n我读完了感觉不错。和《代码整洁之道》一样，我现在还是一个新人，还没有没有遇到什么真实的复杂情况，有些需要重构的坏味道没有遇到，我就是凭我自己的感觉。\n个人来说，他的前几章讲的思想原则就值得去看。\n\n重构的最佳时机是加入新功能之前；\n重构要小步走；\n何时不该重构；\n重构会让开发更快。\n\n书的后面就是在讲重构的方法了，提供了一堆术语，方便和别人交流。这些反而就不是很重要了，需要的时候查表就行了。书在最后还贴心得给了一个坏味道与重构手法速查表。\n确实是实用的书，当成词典就行了。\n","tags":["书籍"]},{"title":"游戏引擎学习之旅（3）渲染器重构","url":"/2025/05/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%E6%B8%B2%E6%9F%93%E5%99%A8%E9%87%8D%E6%9E%84/","content":"重构的理由跟着视频写为什么需要重构呢？你只需要从视频或者代码库里把东习 steal 出来不就行了吗？这是因为我在看他的视频的时候感觉非常熟悉，他在讲 OpenGL 的时候抽象出了一个类似的渲染器（Renderer），我想就把学习 OpenGL 写的代码哪过来不久行了吗？。确实行了，屏幕上有预期的图片绘出。但是他的设计思路是把渲染的 API 和具体的图形学 API 的实现分开，方便后续扩展API，比如Vulkan，可以让使用引擎的人不知道渲染的具体实现。我的当前的代码结构没有这个抽象的 API ，直接就是 OpenGL 的具体实现，这就我直接加上的代码就不合适了。于是就开启了重构工作。\n开始重构我从 The Cherno 那里 steal 了抽象 API ，我要做的就是让我的现在类继承抽象的 API 。我感觉没什么困难的，可是我基本上是第一次做这种类似的工作，修改了一处就报错，代码无法运行，有一种无从下手的感觉。从 The Cherno 那里 steal 的抽象 API是阻挡我修改的难关，不仅成员函数的参数和数量不同，里面的数据也进行了封装，成员变量的类型和数量不同，不能直接加上继承就让代码运行。种种限制让我对着代码发愁。这很挫败，难道我应该跟着视频走，回退到没有合并代码的版本吗？有没有什么技巧可以帮我重构呢？\n还真有，我想起来了这本著名的《重构 改善既有代码的设计》，之前我一直用不上就没有读，现在是时候读读这本书了。这本书给了我很大的帮助。对我来说学到的重要的思想是：小步走，让代码保持可工作状态和重构会让开发更快。这让我静下心来，不想着一步到位，而是慢慢调整代码。我一步步得重构了原本的代码，并且加深了我对这整个渲染器的设计的理解。\n在重构中理解设计思路 我在The Cherno 的 Layout 的布局的 API 传入的参是 自定义的枚举类型，float2 就表示两个float类型的布局，把原本的类型和个数这个参数给些在了一起，我在用这个自定义类形的参数替代原来的 float 和 unsigned int 时， 想着这里，肯定有一个把这个变量变换为原来的两个的函数，我果然看到了两个相关的函数，一个计算大小，一个返回类型。\n 他的顶点数组的创建用的是Create()函数，我之前没有意思到，我重构的时候意识才到这个函数的作用是让调用渲染器时只包含抽象 API 的头文件而不用与 具体的OpenGL类的图形学 API 的实现相关。\nRendererAPI，RenderCommand，Renderer类之间的关系是后者调用前者。 渲染器的 Draw 和 Clear 是一个静态函数时，不用具体实现一个Renderer类。这里整个Renderer的实现的接口都是方便引擎的使用者调用。我在这里重构了几天既让用户方便，也让开发者有一个结构更加合理的代码库，方便后续开发。\n想法 这种跟上思路的感觉很棒。\n这次没有学太多的新东西，基本上是 OpenGL 系列里的东西，这是的重点是重构。\n我确实做的是重构，写了几天，运行的结果还是和之前一模一样。难怪书里开头问了一个问题：如何跟经理解释重构的意义。\n书里说重构的最佳时机就是在添加新功能之前，这个我也认同，我就是在添加相机功能之前重构代码。\n提高了我重构的意识。当代码报了一个头文件循环包含的错误时，我想这是一个坏味道，就检查了其他的代码的头文件的包含，去掉多余的。\n在重构的过程中真正学到了东西，而不是从theCherno那里steal。也难怪Peter Norvig说要learning by doing了。\n 我看书的时候意识到theCherno的教学中的代码也是在进行重构。先在屏幕上花画出一个三角型，在不改变显示效果的情况下对代码进行修改，提高代码的可读性和可扩展性，提高代码质量。\n","tags":["游戏引擎"]},{"title":"游戏引擎学习之旅（2）事件系统","url":"/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"视频学到了S022，分析一下Hazel的事件系统是如何实现的。\n\n\n先看看Application类里如何处理jj下面这里的 变量层栈的for循环里，if(e.Handled)为true，就退出不处理了\nvoid Application::OnEvent(Event&amp; e)&#123;\tHZ_PROFILE_FUNCTION();\tEventDispatcher dispatcher(e);\tdispatcher.Dispatch&lt;WindowCloseEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowClose));\tdispatcher.Dispatch&lt;WindowResizeEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowResize));\tfor (auto it = m_LayerStack.rbegin(); it != m_LayerStack.rend(); ++it)\t&#123;\t\tif (e.Handled) \t\t\tbreak;\t\t(*it)-&gt;OnEvent(e);\t&#125;&#125;\n这里显示用了一个dispatcher来处理窗口关闭和窗口重定义大小，这里的写法是判断事件类型是否符合传入的Callback处理函数，如果匹配了，就设置Handled为true（看下面的OnWindowClose返回的true，这样异或为true）。看下面的循环，Handled为true会直接退出。\ndispatch// F will be deduced by the compilertemplate&lt;typename T, typename F&gt;bool Dispatch(const F&amp; func)&#123;\tif (m_Event.GetEventType() == T::GetStaticType())\t&#123;\t\tm_Event.Handled |= func(static_cast&lt;T&amp;&gt;(m_Event));\t\treturn true;\t&#125;\treturn false;&#125;\n\n\n    bool Application::OnWindowClose(WindowCloseEvent&amp; e)    &#123;        m_Running = false;        return true;    &#125;\n\n下面这个事件处理返回的就是false，表示这个事件没有处理完，穿透层，下一层继续处理。\n  bool ImGuiLayer::OnMouseButtonPressedEvent(MouseButtonPressedEvent&amp; e) &#123;ImGuiIO&amp; io = ImGui::GetIO();io.MouseDown[e.GetMouseButton()] = true;      ET_CORE_TRACE(e.ToString());      return false;  &#125;\n\n这个Handled可以在层设置阻挡，ImGuiLayer这里的设置：阻挡成功Handled就设置为true。\nvoid ImGuiLayer::OnEvent(Event&amp; e)&#123;\tif (m_BlockEvents)\t&#123;\t\tImGuiIO&amp; io = ImGui::GetIO();\t\te.Handled |= e.IsInCategory(EventCategoryMouse) &amp; io.WantCaptureMouse;\t\te.Handled |= e.IsInCategory(EventCategoryKeyboard) &amp; io.WantCaptureKeyboard;\t&#125;&#125;\n\n那么如何设置事件类型呢？在事件发生的时候，glfw会自动调用下面我们在窗口初始化的时候设置的回调函数，这里的data.EventCallback(evnet)就是设置Event的类型\n        // Set GLFW callbacks        glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)        &#123;            WindowData&amp; data = *(WindowData*)glfwGetWindowUserPointer(window);            data.Width = width;            data.Height = height;              WindowResizeEvent event(width, height);            data.EventCallback(event);        &#125;);\n\ndata的类型就是下面的函数指针\nusing EventCallbackFn = std::function&lt;void(Event&amp;)&gt;;\n这里提供了Event类型，EventDispatcher提供了处理事件的函数。这就是我对整个事件系统的理解了。\n","tags":["游戏引擎"]},{"title":"游戏引擎学习之旅（1）","url":"/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89/","content":"现状c++：\n\n学了CS106L，AP-1400，作业大部分完成了；图形学基础：\nGAMES101的视频课程看完了，作业写到了MVP变换渲染小奶牛。游戏引擎：\nGAMES104的视频教程视频，没做作业;\n学过SDL2；\n跟着Brackeys入门了Godot的基本操作，对游戏引擎要实现的有一个基本的概念。软件工程：\n读了一些经典书籍：《代码大全》《人月神话》《软件开发心理学》；\n其他相关：《Doom启示录》。\n\n经历我先是学了两天的Vulkan，然后看The Cherno 的 游戏引擎系列的s1~s15。\n比较不自量力的是没有学过OpenGL，想着直接跳入Vulkan，自己用Vulkan写视频里的渲染部分代码。然后就发现Vulkan确实复杂，考虑到我以后很长一段时间都会向The Cherno学习，还是先去学习他的OpenGL系列比较好。而且他后面也用Vulkan，学会了OpenGL应该会让我更好学习Vulkan。\n所以我就暂停学习引擎，去学习OpenGL了。现在看了20节的OpenGL，感觉OpenGL确实比Vulkan简单多了。绘制让我想到了SDL2，MVP变换让我想起了GAMES101，许多知识点开始连起来了。\n想法要有自知之明，脚踏实地。\nThe Cherno的视频确实很好，我学到了许多。\n我接下来就是学习OpenGL，然后是学习游戏引擎，然后我就可以开始为Godot等开源代码做贡献了。\n游戏和游戏引擎真的很有吸引力。游戏设计我不太懂，但是做游戏引擎的成就感和学到的技术是实打实的。技术成就真的会让我开心。\n接下来的系列文章，大多是我的想法体会。如果你也在学习的路上，不妨来看看。\n","tags":["游戏引擎"]},{"title":"英语学习经验分享","url":"/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/","content":"我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。\n\n\n下面是我学习英语的经验。\n\n把手机语言设置为英文；\n读英文的技术书籍和文档；\n看英文电影、动画；\n把游戏语言调成英语；\n写英文博客；\n听英文播客。\n\n有些是一次性的。如把手机语言设置为英文。发朋友圈、微博说自己接下来要读完某本英文书，或是每天读半小时，通过一次轻松的行为安排了之后的一段时间。买一个会员，报个考试，通过公开承诺来约束自己。\n最好的学习英语的方式就是用英语学习自己想学的东西。我在读英文技术书籍的时候会刻意挑选英文原版来锻炼自己的英文水平。国外大学的公开课英文的视频、网站和作业同时学技术和英文，是个一石二鸟的方式。\n听播客是一个很好的英语输入途径。听不懂没关系，重要的是培养这个感觉。找到自己的i+1的材料，听就行了。\n\n资源推荐罗肖尼Shawney的bilibili主页，里面有有关英语学习的视频牛顿探索加拿大的英语学习播客单集 ，别忘了shownote的书籍推荐学会提问，这本是提高写作技巧的书。Steam 上的 Life is Strange Remastered，注意把语言调成英文。\n","tags":["英语"]},{"title":"阅读《代码大全》","url":"/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/","content":"《代码大全》我读了两遍，先是读到英文版，后来又读了一边中文版。读英文版时，我还想着“routine”该怎么翻译，结果看中文翻译翻成了“子程序”，意思没原文丰富。中英文版都不错完全推荐。\n这本书讲的内容真的是软件工程的基础，跟我看完了感觉在各个方面长见识，但又很难说是什么，感觉就是为设计软件打了地基，知识成为了我的血液。书里的代码编写、变量命名、注释等我在其他的书籍视频里看过好几次，这本书把软件的方方面面串联起来，给了我一个大的脉络。先读这本书会为软件工程打一个很好的基础。\n全书令我影响深刻的观点论述有：\n\n用隐喻来学习；\n软件工程就是管理复杂度；\n不要陷进语言，自己定义用法；\n伪代码编程过程；\n最后几章的关于人的个性，布局排版的艺术。\n\n有些东西确实不太懂，毕竟我还没有在真实的工业环境里工作过，设计、编码、测试等技能没有经过检验。不只这本书，《clean code》里的后半部分我就不懂；《程序开发心理学》我读得挺有意思，但是每章结束后问管理者和程序员的问题我无法回答；不过《人月神话》没有讨论什么技术，谈的是思想，写得也好，不愧对它的声誉。\n","tags":["书籍"]}]