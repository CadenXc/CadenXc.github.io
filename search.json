[{"title":"《废都物语》游玩体验","url":"/2025/06/09/%E3%80%8A%E5%BA%9F%E9%83%BD%E7%89%A9%E8%AF%AD%E3%80%8B%E6%B8%B8%E7%8E%A9%E4%BD%93%E9%AA%8C/","content":"尽量不剧透。\n\n这个游戏剧情融合了各种神话，虚构了一个丰富的大河世界。主角有四个出身可以选，四个出身的线大体相同，但又有各自独特的剧情，每条线各自揭开了部分剧情的谜底。可以在酒馆里集结队友，踏上旅途，像跑团。游戏内有多名队友，陪你冒险，都有着独特的个性，喜欢某位角色可以一直带着，可能会解锁队友个人的独特剧情。在游戏过程中也有挺恶搞的地方，比如睡美人、怪仙，夜种王，也许会让你心领神会，忍俊不禁。\n个人是按盗贼-&gt;骑士-&gt;法师-&gt;贤者的顺序玩了共计四周目，并不是那种多周目大佬。游戏难度我选的普通，因为游戏的的多周目有继承机制，所以在我玩的周目里最难的是第一周目的盗贼出身。身板脆，不知道隐藏宝箱在哪里，对地图多大和谜题没有底，完全对世界陌生，这是我开荒的体验。\n挺过初期的困难后就渐渐被玩法和剧情吸引了。 作为一个宝可梦爱好者，对西方奇幻和跑团也颇有兴趣的人，这个经典RPG战斗，那些非战斗的技能和以前宝可梦里的秘传技能等在战斗外的地方也可以使用的技能类似，龙与地下城式的队友集结和地图探险，不错。但是剧情就没有仔细看，以至于有的地方卡关查攻略了。不过这样也可以，我本来玩的时候也没有想着剧情会多优秀，到了后面几周目才渐渐琢磨出味道来，之后看了别人剧情梳理我才对剧情有一个完整的概念。\n本来第一周目打得我都快弃坑了，不经意间在一次回档的时候没有选择打死龙蛋而是试着给它命名，结果孵出来了一个龙女，虽然这剧情有些熟悉但是我喜欢。想想这我之前不就算是错过了吗，鬼使神差让我读了一个前一点的档，出来一个龙女儿，这我得带着她通关呀。就继续打了，之后渐渐喜欢上了这个游戏。\n游玩体验最好的是第四周目，打最终boss时，主角是贤者防御高，先给队友加攻加防，然后一直放回复技能就行，输出就靠队友，无脑点威力最高的技能。\n别被画风劝退了，挺不错的。或者也可以等等重置版。\n","tags":["游戏"]},{"title":"MIT 6.S081 Operating System Engineering Lab2 system calls","url":"/2025/07/03/MIT-6-S081-Operating-System-Engineering-Lab2-system-calls/","content":"注册系统call在以下文件里添加代码\n// user/usys.plentry(&quot;trace&quot;);\n\n // user/user.h int trace(int);\n// kernel/syscall.h.#define SYS_trace  22\n\n// syscall.cextern uint64 sys_trace(void);static uint64 (*syscalls[])(void) = &#123;// ...[SYS_trace]   sys_trace, // add this line&#125;;\n\n\n\nSystem call tracing// proc.hstruct proc &#123;  int mask; //for tracing&#125;;\n\n// syscall.cconst char *syscall_names[] = &#123;&quot;placeholder&quot;, &quot;fork&quot;, &quot;exit&quot;, &quot;wait&quot;, &quot;pipe&quot;, &quot;read&quot;, &quot;kill&quot;, &quot;exec&quot;, &quot;fstat&quot;, &quot;chdir&quot;,&quot;dup&quot;, &quot;getpid&quot;, &quot;sbrk&quot;, &quot;sleep&quot;, &quot;uptime&quot;, &quot;open&quot;, &quot;write&quot;, &quot;mknod&quot;,&quot;unlink&quot;, &quot;link&quot;, &quot;mkdir&quot;, &quot;close&quot;, &quot;trace&quot;, &quot;sysinfo&quot;,&#125;;voidsyscall(void)&#123;  int num;  struct proc *p = myproc();  num = p-&gt;trapframe-&gt;a7;  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;    p-&gt;trapframe-&gt;a0 = syscalls[num]();      if ((p-&gt;mask &gt;&gt; num) &amp; 1)          printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);  &#125; else &#123;    printf(&quot;%d %s: unknown sys call %d\\n&quot;,            p-&gt;pid, p-&gt;name, num);    p-&gt;trapframe-&gt;a0 = -1;  &#125;&#125;\n\n// kernel/proc.cintfork(void)&#123;// ...  np-&gt;mask = p-&gt;mask; // copy mask from parent to child// ...&#125;\n\n// sysproc.cuint64 sys_trace(void)&#123;    int mask;    if(argint(0, &amp;mask) &lt; 0)        return -1;    struct proc *p = myproc();    p-&gt;mask |= mask;    return 0;&#125;\n\n\nSysinfo// proc.cuint64 countproc(void)&#123;  struct proc *p;  int count = 0;  for(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;        if (p-&gt;state != UNUSED)            count++;  &#125;  return count;&#125;\n\n// kalloc.cuint64 kfreemem(void)&#123;    struct run *r;    uint64 total = 0;     acquire(&amp;kmem.lock);    for (r = kmem.freelist; r; r = r-&gt;next)        total += PGSIZE;    release(&amp;kmem.lock);    return total;&#125;\n\n// sysproc.cuint64 sys_sysinfo(void)&#123;  struct sysinfo info;  uint64 addr;  if (argaddr(0, &amp;addr) &lt; 0)        return -1;  info.freemem = kfreemem();  info.nproc = countproc();    struct proc *p = myproc();  if(copyout(p-&gt;pagetable, addr, (char *)&amp;info, sizeof(info)) &lt; 0)      return -1;    return 0;&#125;","tags":["操作系统","6.S081"]},{"title":"MIT 6.S081 Operating System Engineering Lab1 Xv6 and Unix utilities","url":"/2025/06/27/MIT-6-S081-Operating-System-Engineering-Lab1-Xv6-and-Unix-utilities/","content":"sleep这个挺简单的，先给大家自信。\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123;    if (argc != 2) &#123;        printf(&quot;sleep error: just need one argument. \\n&quot;);        exit(1);    &#125;    sleep(atoi(argv[1]));    exit(0);&#125;\n\n\npingpong这里fork之后，父子进程就有了相同的管道的文件描述符。\n父进程先写入字符，然后等待子进程处理后接收传回来的字符。\n#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123;    char buf[1];    int n;    int status;    int fds[2];    pipe(fds);    int pid = fork();    if (pid == 0) &#123;        n = read(fds[0], buf, sizeof(buf));        printf(&quot;%d: received ping\\n&quot;, getpid());        write(fds[1], buf, n);    &#125; else &#123;        write(fds[1], &quot;p&quot;, 1);        wait(&amp;status);        n = read(fds[0], buf, sizeof(buf));        printf(&quot;%d: received pong\\n&quot;, getpid());    &#125;    exit(0);&#125;\n\n\nprimes网站上给的论文Bell Labs and CSP Threads很好得说明了原理。我先没有用fork，只用pipe模拟了这个sieve。因为无法确定终止的循环数，而且网站上提示用递归，所以用迭代做这题是合理的。\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;void sieve(int read_fd) &#123;    int p;    char buf[1];    if (read(read_fd, buf, 1) == 0) &#123;        close(read_fd);        exit(0);    &#125;    p = buf[0];    printf(&quot;prime %d\\n&quot;, p);        int fds[2];    pipe(fds);    if (fork() == 0) &#123;        close(fds[1]);        sieve(fds[0]);        exit(0);    &#125; else &#123;        close(fds[0]);        while (read(read_fd, buf, 1)) &#123;            if (buf[0] % p != 0) &#123;                write(fds[1], buf, 1);            &#125;        &#125;    &#125;    close(read_fd);    close(fds[1]);    wait(0);    exit(0);&#125;int main(int argc, char *argv[])&#123;    int fds[2];    pipe(fds);    for (int i = 2; i &lt;= 35; i++) &#123;        write(fds[1], &amp;i, 1);    &#125;    close(fds[1]);    sieve(fds[0]);    exit(0);&#125;\n\n\nfind这个参考了ls.c。c语言的字符串处理是这里较难的部分。\n#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;char* getname(char *path)&#123;    char *p;    for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != &#x27;/&#x27;; p--)        ;    p++;    return p;&#125;void find(char *path, char *target)&#123;    if (strcmp(target, &quot;.&quot;) == 0) &#123;        exit(0);    &#125;    if (strcmp(target, &quot;..&quot;) == 0) &#123;        exit(0);    &#125;    char buf[512], *p;    int fd;    struct dirent de;    struct stat st;    if((fd = open(path, 0)) &lt; 0)&#123;        fprintf(2, &quot;find: cannot open %s\\n&quot;, path);        return;    &#125;    if(fstat(fd, &amp;st) &lt; 0)&#123;        fprintf(2, &quot;find: cannot stat %s\\n&quot;, path);        close(fd);        return;    &#125;    switch (st.type) &#123;        case T_FILE:            if (strcmp(getname(path), target) == 0) &#123;                printf(&quot;%s\\n&quot;, getname(buf));            &#125;            break;        case T_DIR:            if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) &#123;                printf(&quot;find: path too long\\n&quot;);                break;            &#125;            strcpy(buf, path);            p = buf+strlen(buf);            *p++ = &#x27;/&#x27;;            while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) &#123;                if(de.inum == 0)                    continue;                memmove(p, de.name, DIRSIZ);                p[DIRSIZ] = 0;                if(stat(buf, &amp;st) &lt; 0)&#123;                    printf(&quot;find: cannot stat %s\\n&quot;, buf);                    continue;                &#125;                char fname[DIRSIZ+1];                memmove(fname, de.name, DIRSIZ);                fname[DIRSIZ] = 0;                if (strcmp(fname, &quot;.&quot;) == 0) &#123;                    continue;                &#125;                if (strcmp(fname, &quot;..&quot;) == 0) &#123;                    continue;                &#125;                char cpath[512];                int path_len = strlen(path);                memmove(cpath, path, path_len);                cpath[path_len] = &#x27;/&#x27;;                memmove(cpath + path_len + 1, fname, strlen(fname));                cpath[path_len + 1 + strlen(fname)] = 0;                if (st.type == T_DIR) &#123;                    find(cpath, target);                &#125; else if (st.type == T_FILE) &#123;                    if (strcmp(fname, target) == 0) &#123;                        printf(&quot;%s/&quot;, path);                        printf(&quot;%s\\n&quot;, fname);                    &#125;                &#125;            &#125;            break;    &#125;    close(fd);&#125;int main(int argc, char *argv[])&#123;    if (argc == 1) &#123;        printf(&quot;find error: too few parameters!\\n&quot;);        exit(1);    &#125;    if (argc &gt; 3) &#123;        printf(&quot;find error: too many parameters!\\n&quot;);        exit(1);    &#125;    if(argc == 2)&#123;        find(&quot;.&quot;, argv[1]);        exit(0);    &#125;    find(argv[1], argv[2]);    exit(0);&#125;\n\n\nxargs我之前都没有用过这个命令，看这篇文章了解了它的功能，感觉挺好用的。\n这里的思路简单，就是先把argv和管道运算符 | 传来的参数放在一个数组里，再用fork和exec执行。前面的处理有几点要注意：\n\n|传来的参数要从0 描述符里读取；\n新数组要排除argv[0]，不然可能递归调用xargs；\n从示例可知，xargs之后的参数要与前面的每一行拼接运行。\n\n没有写 -n 参数，评分系统也过了，不过要写也能写。\n#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;char* readline() &#123;    char* buf = malloc(100);    if (!buf) &#123;        return 0;    &#125;    char* p = buf;    while (read(0, p, 1) == 1) &#123;        if (*p == &#x27;\\n&#x27; || *p == 0) &#123;            *p = 0;            return buf;        &#125;        p++;    &#125;    if (p != buf) &#123;        *p = 0;        return buf;    &#125;    free(buf);    return 0;&#125;int main(int argc, char *argv[])&#123;    if (argc &lt; 2) &#123;        printf(&quot;Usage: xargs command&quot;);        exit(1);    &#125;        char* arr[MAXARG];    char* line;    while ((line = readline()) != 0) &#123;        int arr_index = 0;        for (int i = 1; i &lt; argc; i++) &#123;            arr[arr_index++] = argv[i];        &#125;        char* p = line;        while (*p) &#123;            while (*p == &#x27; &#x27;) p++;            if (*p == 0) break;            char* start = p;            while (*p &amp;&amp; *p != &#x27; &#x27;) p++;            int len = p - start;            char* arg = malloc(len + 1);            if (!arg) &#123;                printf(&quot;malloc failed\\n&quot;);                exit(1);            &#125;            for (int i = 0; i &lt; len; i++) &#123;                arg[i] = start[i];            &#125;            arg[len] = 0;            arr[arr_index++] = arg;            if (arr_index &gt;= MAXARG - 1) break;        &#125;        arr[arr_index] = 0;        int pid = fork();        if (pid == 0) &#123;            exec(arr[0], arr);            printf(&quot;exec failed!\\n&quot;);            exit(1);        &#125; else &#123;            wait((int *)0);        &#125;        for (int i = argc - 1; i &lt; arr_index; i++) &#123;            free(arr[i]);        &#125;        free(line);    &#125;    exit(0);&#125;\n\n\n写起来还蛮有意思的。\n\nReferenceMIT 6.S081: Operating System Engineering - CS自学指南\n","tags":["操作系统","6.S081"]},{"title":"《重构 改善既有代码的设计》简评","url":"/2025/05/29/%E3%80%8A%E9%87%8D%E6%9E%84%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AE%80%E8%AF%84/","content":"读本书的缘由看这里：游戏引擎学习之旅（2）渲染器重构。\n我读完了感觉不错。和《代码整洁之道》一样，我现在还是一个新人，还没有没有遇到什么真实的复杂情况，有些需要重构的坏味道没有遇到，我就是凭我自己的感觉。\n个人来说，他的前几章讲的思想原则就值得去看。\n\n重构的最佳时机是加入新功能之前；\n重构要小步走；\n何时不该重构；\n重构会让开发更快。\n\n书的后面就是在讲重构的方法了，提供了一堆术语，方便和别人交流。这些反而就不是很重要了，需要的时候查表就行了。书在最后还贴心得给了一个坏味道与重构手法速查表。\n确实是实用的书，当成词典就行了。\n","tags":["书籍"]},{"title":"哲学和心理学书籍推荐","url":"/2025/07/12/%E5%93%B2%E5%AD%A6%E5%92%8C%E5%BF%83%E7%90%86%E5%AD%A6%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/","content":"哲学哲学通识课：《苏菲的世界》\n我个人比较喜欢斯多葛主义，下面列出我看过的相关书籍：\n\n《人生的智慧》\n《活出生命的意义》\n《斯多葛生活哲学》\n《沉思录》\n《像哲学家一样生活》\n《障碍是道路》可以在这个斯多葛主义书单可以看看还有什么其它书。\n\n心理学这个和脑科学或者其他概念我不太好划分，有些可以放在其他分类里。这里就推这些吧。\n《活出生命的意义》《少有人走的路》《改变的历程》《心理控制方法》《思考致富》《论人的成长》\n","tags":["书籍","分享"]},{"title":"游戏引擎学习之旅（1）","url":"/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89/","content":"现状c++：\n\n学了CS106L，AP-1400，作业大部分完成了；图形学基础：\nGAMES101的视频课程看完了，作业写到了MVP变换渲染小奶牛。游戏引擎：\nGAMES104的视频教程视频，没做作业;\n学过SDL2；\n跟着Brackeys入门了Godot的基本操作，对游戏引擎要实现的有一个基本的概念。软件工程：\n读了一些经典书籍：《代码大全》《人月神话》《软件开发心理学》；\n其他相关：《Doom启示录》。\n\n经历我先是学了两天的Vulkan，然后看The Cherno 的 游戏引擎系列的s1~s15。\n比较不自量力的是没有学过OpenGL，想着直接跳入Vulkan，自己用Vulkan写视频里的渲染部分代码。然后就发现Vulkan确实复杂，考虑到我以后很长一段时间都会向The Cherno学习，还是先去学习他的OpenGL系列比较好。而且他后面也用Vulkan，学会了OpenGL应该会让我更好学习Vulkan。\n所以我就暂停学习引擎，去学习OpenGL了。现在看了20节的OpenGL，感觉OpenGL确实比Vulkan简单多了。绘制让我想到了SDL2，MVP变换让我想起了GAMES101，许多知识点开始连起来了。\n想法要有自知之明，脚踏实地。\nThe Cherno的视频确实很好，我学到了许多。\n我接下来就是学习OpenGL，然后是学习游戏引擎，然后我就可以开始为Godot等开源代码做贡献了。\n游戏和游戏引擎真的很有吸引力。游戏设计我不太懂，但是做游戏引擎的成就感和学到的技术是实打实的。技术成就真的会让我开心。\n接下来的系列文章，大多是我的想法体会。如果你也在学习的路上，不妨来看看。\n","tags":["游戏引擎"]},{"title":"代码之外的推荐","url":"/2025/06/02/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E6%8E%A8%E8%8D%90/","content":"浏览器插件\nOneTab：压缩页面，减少内存占用，方便搜集临时的不想的收藏的页面，配合浏览器的分组功能效果更佳；\n沙拉查词：聚合词典划词翻译；\nuBlacklist：屏蔽网站用，清理 [内容农场]；\nGet RSS Feed URL：获取当前网页的RSS订阅；\n微信读书笔记助手：复制网页版微信读书画线评论；\nImmersive Translate：内嵌式网页翻译；\nMarinara: Pomodoro® Assistant：一个番茄工作法的番茄钟。\n\nWindows工具\nSumatra PDF：功能强大的电子书阅读器，可以打开种电子书格式；\n小狼毫输入法：好用的输入法软件；\nKeePass：密码管理工具；\nGeek：知名卸载工具；\nQbittorrent：磁力下载软件，配合资源下载网址海盗湾使用；\nSpaceSniffer：磁盘空间分析软件；\nqimgv：图片浏览器：觉得Windows自带的图片显示不好用，可以试试这个；\nPixPin：截图贴图工具；\nPotPlayer：可能是最好用的视频播放器；\nWox：调用了Everything的软件快速启动器；\nObsidian：markdown笔记软件我选的这个，免费，双链笔记功能强大，推荐配合常青笔记，下载插件能让软件更好用；\nWatt Toolkit：加速器，连接 Github 和 Steam；\n爱传送：手机和电脑跨平台传送文件；\nLibreOffice：Wps和Micro Office的开源平替；\nGIMP：Adobe Photoshop 的开源平替；\n网易UU远程：远程控制电脑；\nOBS：开源视频录制软件；\nSourcetree：Git 图形界面工具；\nCubox：跨平台浏览器页面管理；\nFluent Reader：rss阅读器。\n\n安卓App在应用商店、github或者浏览器上能找到：\n\nLibrera：打开Txt，PDF，Mobi等各种格式的文件，用来读书；\n微信读书：电子书书城，阅读购买电子书；\nflomo：有浏览器页面，互传文字挺方便。\nHabitica：游戏化任务管理。\n小宇宙：听播客；\nZArchiver&#x2F;MT Manager：手机文件管理，压缩包解压；\nFeedMe：安卓端 RSS 阅读器。\n小青帐：记账软件。\n\n推荐学习的技能\n双拼练习：一种打字拼音输入法，有多种映射方式，选一种即可；\nMarkdown：轻量级的标记语言，方便排版，写笔记，博客文章用；\nLatex：一种编程语言，方便排版，写论文用。\n\n","tags":["分享"]},{"title":"游戏引擎学习之旅（2）事件系统","url":"/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"视频学到了S022，分析一下Hazel的事件系统是如何实现的。\n\n\n先看看Application类里如何处理jj下面这里的 变量层栈的for循环里，if(e.Handled)为true，就退出不处理了\nvoid Application::OnEvent(Event&amp; e)&#123;\tHZ_PROFILE_FUNCTION();\tEventDispatcher dispatcher(e);\tdispatcher.Dispatch&lt;WindowCloseEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowClose));\tdispatcher.Dispatch&lt;WindowResizeEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowResize));\tfor (auto it = m_LayerStack.rbegin(); it != m_LayerStack.rend(); ++it)\t&#123;\t\tif (e.Handled) \t\t\tbreak;\t\t(*it)-&gt;OnEvent(e);\t&#125;&#125;\n这里显示用了一个dispatcher来处理窗口关闭和窗口重定义大小，这里的写法是判断事件类型是否符合传入的Callback处理函数，如果匹配了，就设置Handled为true（看下面的OnWindowClose返回的true，这样异或为true）。看下面的循环，Handled为true会直接退出。\ndispatch// F will be deduced by the compilertemplate&lt;typename T, typename F&gt;bool Dispatch(const F&amp; func)&#123;\tif (m_Event.GetEventType() == T::GetStaticType())\t&#123;\t\tm_Event.Handled |= func(static_cast&lt;T&amp;&gt;(m_Event));\t\treturn true;\t&#125;\treturn false;&#125;\n\n\n    bool Application::OnWindowClose(WindowCloseEvent&amp; e)    &#123;        m_Running = false;        return true;    &#125;\n\n下面这个事件处理返回的就是false，表示这个事件没有处理完，穿透层，下一层继续处理。\n  bool ImGuiLayer::OnMouseButtonPressedEvent(MouseButtonPressedEvent&amp; e) &#123;ImGuiIO&amp; io = ImGui::GetIO();io.MouseDown[e.GetMouseButton()] = true;      ET_CORE_TRACE(e.ToString());      return false;  &#125;\n\n这个Handled可以在层设置阻挡，ImGuiLayer这里的设置：阻挡成功Handled就设置为true。\nvoid ImGuiLayer::OnEvent(Event&amp; e)&#123;\tif (m_BlockEvents)\t&#123;\t\tImGuiIO&amp; io = ImGui::GetIO();\t\te.Handled |= e.IsInCategory(EventCategoryMouse) &amp; io.WantCaptureMouse;\t\te.Handled |= e.IsInCategory(EventCategoryKeyboard) &amp; io.WantCaptureKeyboard;\t&#125;&#125;\n\n那么如何设置事件类型呢？在事件发生的时候，glfw会自动调用下面我们在窗口初始化的时候设置的回调函数，这里的data.EventCallback(evnet)就是设置Event的类型\n        // Set GLFW callbacks        glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)        &#123;            WindowData&amp; data = *(WindowData*)glfwGetWindowUserPointer(window);            data.Width = width;            data.Height = height;              WindowResizeEvent event(width, height);            data.EventCallback(event);        &#125;);\n\ndata的类型就是下面的函数指针\nusing EventCallbackFn = std::function&lt;void(Event&amp;)&gt;;\n这里提供了Event类型，EventDispatcher提供了处理事件的函数。这就是我对整个事件系统的理解了。\n","tags":["游戏引擎"]},{"title":"新电脑配置指南","url":"/2025/06/16/%E6%96%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","content":"一、基础设置\n用户名设置系统激活注册时建议使用英文用户名。某些开发工具对路径兼容性较差，含中文可能导致异常。\n\n语言与界面优化  \n\n添加英文语言包，方便中英文切换。  \n在任务栏设置中关闭“小组件”和“任务视图”，并隐藏搜索框，让界面更简洁清爽。\n\n\n系统优化  \n\n将桌面路径迁移到 D 盘（或任意非 C 盘路径），减轻系统盘压力。  \n打开以管理员身份运行的 PowerShell，执行以下命令关闭休眠功能，进一步节省 C 盘空间：  powercfg -h off\n\n个人观点：Windows 的休眠功能并不理想，平时直接关机更为稳妥。\n\n\n\n\n安全策略调整在微软电脑管家（Microsoft PC Manager）中，将除 C 盘以外的所有磁盘添加为“信任磁盘”或“排除项”，避免开发时频繁弹出安全提示。\n\n\n\n二、D 盘目录结构为了避免路径问题，所有文件夹名使用英文，并统一集中管理：\n\nBrowserDownload：浏览器下载目录（如果是 BlowserDownload 是故意拼错可保留）  \nCaden：我的英文名，放一些临时文件或杂项  \nCode：各类项目代码存放地  \nNetworkDiskAndBtDownload：网盘及 BT 下载文件存储  \nRepositories：存放从 GitHub 克隆下来的仓库  \nSoftware：软件下载目录\n\n\n三、软件安装与配置浏览器\n安装 Google Chrome，并将其和系统自带的 Microsoft Edge 的默认下载路径设置为 D:\\BrowserDownload。\n\n开发工具\nGit\nSourcetree：Git 图形化工具\nPowerShell：推荐配合 Oh My Posh 美化终端\nWatt Toolkit：可用于 GitHub 下载加速\n\n输入法与语言工具\n小狼毫输入法配置 雾凇拼音，并使用小鹤双拼方案\n欧陆词典：好用的英文词典\nPixPin：截图标注工具，开源且好用\n\n\n其他软件就不一一列举了，可以参考我写的另一篇 推荐博客。\n\n\n四、数据迁移建议\n浏览器数据：登录账号同步书签和插件即可。\n项目代码 &#x2F; 配置文件：使用 Git 进行云端同步，方便管理。\n敏感或私密数据：不建议上传云盘，可通过 U 盘或局域网方式传输。\n\n\n如果你有更好的建议或配置方式，欢迎在评论区留言交流！\n","categories":["经验分享"],"tags":["Windows"]},{"title":"游戏引擎学习之旅（3）渲染器重构","url":"/2025/05/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%E6%B8%B2%E6%9F%93%E5%99%A8%E9%87%8D%E6%9E%84/","content":"重构的理由跟着视频写为什么需要重构呢？你只需要从视频或者代码库里把东习 steal 出来不就行了吗？这是因为我在看他的视频的时候感觉非常熟悉，他在讲 OpenGL 的时候抽象出了一个类似的渲染器（Renderer），我想就把学习 OpenGL 写的代码哪过来不久行了吗？。确实行了，屏幕上有预期的图片绘出。但是他的设计思路是把渲染的 API 和具体的图形学 API 的实现分开，方便后续扩展API，比如Vulkan，可以让使用引擎的人不知道渲染的具体实现。我的当前的代码结构没有这个抽象的 API ，直接就是 OpenGL 的具体实现，这就我直接加上的代码就不合适了。于是就开启了重构工作。\n开始重构我从 The Cherno 那里 steal 了抽象 API ，我要做的就是让我的现在类继承抽象的 API 。我感觉没什么困难的，可是我基本上是第一次做这种类似的工作，修改了一处就报错，代码无法运行，有一种无从下手的感觉。从 The Cherno 那里 steal 的抽象 API是阻挡我修改的难关，不仅成员函数的参数和数量不同，里面的数据也进行了封装，成员变量的类型和数量不同，不能直接加上继承就让代码运行。种种限制让我对着代码发愁。这很挫败，难道我应该跟着视频走，回退到没有合并代码的版本吗？有没有什么技巧可以帮我重构呢？\n还真有，我想起来了这本著名的《重构 改善既有代码的设计》，之前我一直用不上就没有读，现在是时候读读这本书了。这本书给了我很大的帮助。对我来说学到的重要的思想是：小步走，让代码保持可工作状态和重构会让开发更快。这让我静下心来，不想着一步到位，而是慢慢调整代码。我一步步得重构了原本的代码，并且加深了我对这整个渲染器的设计的理解。\n在重构中理解设计思路 我在The Cherno 的 Layout 的布局的 API 传入的参是 自定义的枚举类型，float2 就表示两个float类型的布局，把原本的类型和个数这个参数给些在了一起，我在用这个自定义类形的参数替代原来的 float 和 unsigned int 时， 想着这里，肯定有一个把这个变量变换为原来的两个的函数，我果然看到了两个相关的函数，一个计算大小，一个返回类型。\n 他的顶点数组的创建用的是Create()函数，我之前没有意思到，我重构的时候意识才到这个函数的作用是让调用渲染器时只包含抽象 API 的头文件而不用与 具体的OpenGL类的图形学 API 的实现相关。\nRendererAPI，RenderCommand，Renderer类之间的关系是后者调用前者。 渲染器的 Draw 和 Clear 是一个静态函数时，不用具体实现一个Renderer类。这里整个Renderer的实现的接口都是方便引擎的使用者调用。我在这里重构了几天既让用户方便，也让开发者有一个结构更加合理的代码库，方便后续开发。\n想法 这种跟上思路的感觉很棒。\n这次没有学太多的新东西，基本上是 OpenGL 系列里的东西，这是的重点是重构。\n我确实做的是重构，写了几天，运行的结果还是和之前一模一样。难怪书里开头问了一个问题：如何跟经理解释重构的意义。\n书里说重构的最佳时机就是在添加新功能之前，这个我也认同，我就是在添加相机功能之前重构代码。\n提高了我重构的意识。当代码报了一个头文件循环包含的错误时，我想这是一个坏味道，就检查了其他的代码的头文件的包含，去掉多余的。\n在重构的过程中真正学到了东西，而不是从theCherno那里steal。也难怪Peter Norvig说要learning by doing了。\n 我看书的时候意识到theCherno的教学中的代码也是在进行重构。先在屏幕上花画出一个三角型，在不改变显示效果的情况下对代码进行修改，提高代码的可读性和可扩展性，提高代码质量。\n","tags":["游戏引擎"]},{"title":"游戏引擎学习之旅（4）批渲染和调试","url":"/2025/06/08/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%884%EF%BC%89%E6%89%B9%E6%B8%B2%E6%9F%93%E5%92%8C%E8%B0%83%E8%AF%95/","content":"上次博客之后，先是抽象出了一个Renderer2D的类。这个类调用了是Renderer部分其他的代码，不知道OpenGL或者其他图形学API的具体实现如何。这样用户使用的时候只需要调用提供的静态函数就行了，图形学API是不影响用户写好的代码，是一个相当清晰的不错的设计。\n 接下来就是在这个已经使用可以工作的Rednerer2D类里实现批渲染（Batch Rendering）。\n 我对批渲染很有好感，这个得加进引擎里。之前用SDL2画地牢的地图时，我试着在更新初始化地图值时把绘制命令放在了for循环，导致每添加到一个图片到SDL_surface里就会调用一次绘制命令。这样地图绘制时是从上往下一点一点渲染，花了一百多秒完成。之后把绘制命令拿出for循环，这样就是在等Surface一次更新完后在绘制，地图一瞬间就绘制好了。\n实现批渲染的方法。之前的实现是用一个数组存储，把位置纹理坐标等放在起，每个图形都是单独的一个数组，现在把数组改成结构体，不同的成员变量对应了不同属性，更新的值会插入在一个数组里。另有一个结构体来管理各种数值，前面的和纹理数组都在这个里面当成为变量。声明上述为一个静态结构体，每次调用是设置的数值等都在这里设置，这样在绘制的时候只使用结构体里的一个索引数组，渲染是就把前面的整个当成是一个图形绘制。\n不过在添加纹理的时候出了一个Bug。我只绘制纯颜色块时正确，绘制带纹理的方块时候就是黑的，没有渲染出纹理，而本该是纯颜色的方块却有渲染出了纹理。\n那就开始Debug吧。我先是查看代码，看了最近两次提交代码的修改部分，没发现问题。然后对这个错误进行测试，发现当绘制多个带纹理的方块时，本该是纯颜色的方块会渲染出最后一个绑定的纹理。问题出在了纹理设置上。当我在纹理渲染的函数里手动把slot 修改为0.0f时，渲染出了该有给的纹理，把slot设为没有纹理的绑定的值（比如3）就会变成默认的白色，说明这是纹理slot绑定出的问题。然后我找到了纹理绑定的那段代码，传了slot值（不指定就是默认复制的0），功能正常。\n我有些震惊与这样的错误。我现在学习这个引擎的方式的流程如下。\n\n看一遍视频，了解本次代码该实现的效果；\n点开GitHub对应提交的代码提交，理解代码的设计和实现；\n编写代码；\n改错；\n提交到GitHub仓库。\n\n我再次看视频发现视频里是有传入参数的，所以这个提交的代码就没有达成视频里的功能。我默认认为代码要测试无误才提交，也相信这个是对的。但是TheCherno这个大牛居然在提交的时候没有注意到这个。\n也许TheCherno是想提醒我要多思考，不要光剽窃代码。想告诉我大牛也会有不小心的时候，想说我也可以成为大牛。\n谢谢你，TheCherno！\n","tags":["游戏引擎"]},{"title":"英语学习经验分享","url":"/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/","content":"我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。\n\n\n下面是我学习英语的经验。\n\n把手机语言设置为英文；\n读英文的技术书籍和文档；\n看英文电影、动画；\n把游戏语言调成英语；\n写英文博客；\n听英文播客。\n\n有些是一次性的。如把手机语言设置为英文。发朋友圈、微博说自己接下来要读完某本英文书，或是每天读半小时，通过一次轻松的行为安排了之后的一段时间。买一个会员，报个考试，通过公开承诺来约束自己。\n最好的学习英语的方式就是用英语学习自己想学的东西。我在读英文技术书籍的时候会刻意挑选英文原版来锻炼自己的英文水平。国外大学的公开课英文的视频、网站和作业同时学技术和英文，是个一石二鸟的方式。\n听播客是一个很好的英语输入途径。听不懂没关系，重要的是培养这个感觉。找到自己的i+1的材料，听就行了。\n\n资源推荐罗肖尼Shawney的bilibili主页，里面有有关英语学习的视频牛顿探索加拿大的英语学习播客单集 ，别忘了shownote的书籍推荐学会提问，这本是提高写作技巧的书。Steam 上的 Life is Strange Remastered，注意把语言调成英文。\n","tags":["英语"]},{"title":"阅读《代码大全》","url":"/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/","content":"《代码大全》我读了两遍，先是读到英文版，后来又读了一边中文版。读英文版时，我还想着“routine”该怎么翻译，结果看中文翻译翻成了“子程序”，意思没原文丰富。中英文版都不错完全推荐。\n这本书讲的内容真的是软件工程的基础，跟我看完了感觉在各个方面长见识，但又很难说是什么，感觉就是为设计软件打了地基，知识成为了我的血液。书里的代码编写、变量命名、注释等我在其他的书籍视频里看过好几次，这本书把软件的方方面面串联起来，给了我一个大的画画。先读这本书会为软件工程打一个很好的基础。\n全书令我影响深刻的观点论述有：\n\n用隐喻来学习；\n软件工程就是管理复杂度；\n不要陷进语言，自己定义用法；\n伪代码编程过程；\n最后几章的关于人的个性，布局排版的艺术。\n\n有些东西确实不太懂，毕竟我还没有在真实的工业环境里工作过，设计、编码、测试等技能没有经过检验。不只这本书，《clean code》里的后半部分我就不懂；《程序开发心理学》我读得挺有意思，但是每章结束后问管理者和程序员的问题我无法回答；不过《人月神话》没有讨论什么技术，谈的是思想，写得也好，不愧对它的声誉。\n","tags":["书籍"]}]