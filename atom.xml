<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CadenXc&#39;s Blog</title>
  
  
  <link href="https://cadenxc.com/atom.xml" rel="self"/>
  
  <link href="https://cadenxc.com/"/>
  <updated>2025-12-21T06:45:13.698Z</updated>
  <id>https://cadenxc.com/</id>
  
  <author>
    <name>CadenXc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简历写作技巧</title>
    <link href="https://cadenxc.com/2025/12/21/%E7%AE%80%E5%8E%86%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>https://cadenxc.com/2025/12/21/%E7%AE%80%E5%8E%86%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/</id>
    <published>2025-12-21T06:42:27.000Z</published>
    <updated>2025-12-21T06:45:13.698Z</updated>
    
    <content type="html"><![CDATA[<p>不要作假<br>姓名、电话、邮箱必需。<br>院校、专业、修读时间必需<br>(实习&#x2F;工作经历，如果有的话）公司名称、职位、工作&#x2F;实习时间必需<br>写在简历上的东西要百分百会</p><p>可以结合STAR原则<br>注：STAR原则，即Situation背景、Task任务、Action行动、Result产出。</p><p>做了什么 + 成果（动宾+产出，避免口语<br>时间（教育，实习等）由近到远</p><p>一页纸简历<br>在美国，人们会建议工作经验不足10年的求职者将简历压缩成1页；超过10年的，可以使用1.5至2页篇幅。</p><p>如果成绩、各科成绩、四六级等等排名好分数高，可以写；否则就不要写，仅写拥有某项证书即可。<br>写出参照物：gpa xxx 前xxx</p><p><strong>参考JD</strong> ，编辑经历 JD就是考纲。<br>简历定制，不同行业，不同简历<br>要和岗位相关</p><p>照片按投递岗位要求和自身颜值酌情提供。如果要放一张照片，用证件照&#x2F;工作照</p><p>个人评价一般不写，容易有凑字数嫌疑，如果一定要写建议转换为个人优势，简略写。<br>如果提交电子版，建议PDF。<br>邮件附件，以“xxx求职xxx岗位.pdf&#x2F;doc&#x2F;docx”命名</p><p>可以有资格证书、技能、兴趣爱好、个人评价等内容，但最好和职位相关或是你个人亮点。</p><p>邮件命名：姓名 + 岗位（可以 + 一句话）。正文信息按照标准邮件格式，可以补充很多信息例如对公司的了解 为什么想加入 你的优势等等。<br>作品集可以用链接</p><p>简历筛选的逻辑是反复打捞，想被看到就要勤刷新</p><p>邮件主题，以“XXX求职&#x2F;应聘XXX职位”命名</p><p>不使用第一人称。要避免使用第一人称 。除了求职意向这一部分需要第一人称外， 其他部分应该尽量使用第三人称。</p><p>打开空白文档，事无巨细地把你这段时间实习中的一些成果、一些事情都记下来，先不管。然后从中提炼出实习经历。 问下是否能不被别人抄走，是否具体。是我的东西，我的特别的经历，无法被别人简单抄走。</p><hr><p><a href="https://www.bilibili.com/video/BV1dEPTemEVp?spm_id_from=333.788.player.switch&vd_source=c7d1bbd34d9982d8b421763e8204f67d">【个人经验】简历修改实战及面试建议_哔哩哔哩_bilibili</a><br><a href="https://www.bilibili.com/video/BV1NL4y1878J?spm_id_from=333.788.videopod.sections&vd_source=c7d1bbd34d9982d8b421763e8204f67d">最强简历攻略：简历制作技巧&#x2F;简历案例分析&#x2F;优秀简历展示&#x2F;热门简历问题答疑【框框的b站大学-简历攻略】_哔哩哔哩_bilibili</a><br><a href="https://github.com/billryan/resume/tree/zh_CN">billryan&#x2F;resume at zh_CN</a><br><a href="https://www.bilibili.com/video/BV1RBWzeXEDJ/?spm_id_from=333.337.search-card.all.click&vd_source=c7d1bbd34d9982d8b421763e8204f67d">大学生零经验必看！如何修改简历找第一份大厂实习？打破实习经验悖论？简历修改|实习渠道分享|大学生求职|大学生职业规划|产品经理|运营_哔哩哔哩_bilibili</a><br><a href="https://www.xiaoyuzhoufm.com/episode/68cd75bba56ca3e0c44cce3d?s=eyJ1IjoiNjIxMTlhZjVlZGNlNjcxMDRhNWU3MjY1In0=">115.改了3份简历，总结了19条建议，你听听看，希望有用 - 轻刀快马 | 小宇宙 - 听播客，上小宇宙</a></p>]]></content>
    
    
    <summary type="html">这些是从相关资料摘抄的一些技巧。 毕竟从不同的地方摘取出来的，难免观点有所不同。</summary>
    
    
    
    
    <category term="简历" scheme="https://cadenxc.com/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>困难问题下的简单解法</title>
    <link href="https://cadenxc.com/2025/11/29/%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E6%B3%95/"/>
    <id>https://cadenxc.com/2025/11/29/%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E6%B3%95/</id>
    <published>2025-11-29T13:43:01.000Z</published>
    <updated>2025-11-29T13:45:52.816Z</updated>
    
    <content type="html"><![CDATA[<p>以我遇到的自定义模型上的问题为例子。</p><hr><p>问题：这里创建了一个新的资源类型来供自定义模型使用。假设这个资源类型相当于是一根水管，资源类型的名称不可能包含具体的模型类型，管子只能识别一种类型的资源。现在我有五个自定义模型需要通过该水管，如何判断现在通过该水管的是哪个类型的。</p><p>思路一：在使用该资源类型时同时使用一个参数。问题：不兼容原有的系统，维护麻烦。<br>思路二：创建五根水管。费力，如果添加新类型就需要添加新的水管。</p><p>解决方案： 创建子类类，继承父类，只改变其中一个模型类型的参数，问题解决。子类不用写什么，只需要基础父类，通过改一个参数的默认值来判断模型类型。</p><hr><p>问题：这里需要新建一个类，并且被识别为某特定类型的类。在这个系统里，如果一个类的同一父类的另一个子类被系统扫描先到，那么这个类就这会被识别为该类。</p><p>思路一：去掉另一个子类。明明这个被去掉的类里什么也没有实现，并且没有任何地方使用到它，但是去掉之后就是有一个奇妙的bug，这就是老代码堆的魅力呀。<br>思路二：在判断模型类型时对新增加的类做一个特殊判断。这个没有问题了，但是在那个判断类型的地方改代码，有性能问题，而且这样的硬编码对有代码洁癖的你来说完全不能接受。于情于理都要换新方法。</p><p>解决方案：把可能会覆盖的类放在新增的类的后面。从物理或者说系统的意义上先识别你的类。</p><hr><p>让我想起了一本书，《你的灯亮着吗》。也许我现在在人生路上的疑惑，坎坷，有一个我没有意识到的简单解法也说不定。</p>]]></content>
    
    
    <summary type="html">推荐书籍：《你的灯亮着吗》。</summary>
    
    
    
    
    <category term="C++" scheme="https://cadenxc.com/tags/C/"/>
    
    <category term="程序化网格体" scheme="https://cadenxc.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%BD%91%E6%A0%BC%E4%BD%93/"/>
    
    <category term="ProceduralMeshComponent" scheme="https://cadenxc.com/tags/ProceduralMeshComponent/"/>
    
    <category term="思考" scheme="https://cadenxc.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化：游戏存档背后的魔法</title>
    <link href="https://cadenxc.com/2025/10/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%83%8C%E5%90%8E%E7%9A%84%E9%AD%94%E6%B3%95/"/>
    <id>https://cadenxc.com/2025/10/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E8%83%8C%E5%90%8E%E7%9A%84%E9%AD%94%E6%B3%95/</id>
    <published>2025-10-25T07:07:37.000Z</published>
    <updated>2025-10-25T07:12:33.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-核心概念：存档与读档的艺术"><a href="#1-核心概念：存档与读档的艺术" class="headerlink" title="1. 核心概念：存档与读档的艺术"></a>1. 核心概念：存档与读档的艺术</h3><p>序列化与反序列化是程序设计中实现数据持久化的核心机制，我们可以用 RPG 游戏的“存档”和“读档”来形象理解它们。</p><h4 id="1-1-序列化-Serialization-存档"><a href="#1-1-序列化-Serialization-存档" class="headerlink" title="1.1 序列化 (Serialization) ~ 存档"></a>1.1 序列化 (Serialization) ~ 存档</h4><p><strong>序列化</strong>是将程序中复杂的内存对象（如自定义模型、类实例、角色状态等）转化为一种可存储或可传输的<strong>线性字节流</strong>的过程。</p><ul><li><strong>目标：</strong> 将对象从瞬时的内存状态固化，以便存入文件或进行传输。</li></ul><h4 id="1-2-反序列化-Deserialization-读档"><a href="#1-2-反序列化-Deserialization-读档" class="headerlink" title="1.2 反序列化 (Deserialization) ~ 读档"></a>1.2 反序列化 (Deserialization) ~ 读档</h4><p><strong>反序列化</strong>是序列化的逆过程，它负责解析存储介质中的<strong>字节流</strong>，将其重新构建为程序能识别的<strong>内存对象</strong>，从而完整还原之前的状态。</p><ul><li><strong>目标：</strong> 通过读取存储数据，重建运行时对象，恢复程序进度。</li></ul><hr><h3 id="2-实战应用：在现有系统上添加新的本地资源"><a href="#2-实战应用：在现有系统上添加新的本地资源" class="headerlink" title="2. 实战应用：在现有系统上添加新的本地资源"></a>2. 实战应用：在现有系统上添加新的本地资源</h3><p>我的需求是为<strong>自定义模型类型</strong>创建一个<strong>新的本地资源类型</strong>，目的是将模型的参数、类别等信息持久化到本地文件。由于这是一个本地功能（类似于一个 UE 插件的内部存储），且项目约定使用<strong>文本文件（如 JSON）</strong> 进行存储，因此我的工作重点是集成和扩展现有资源系统。</p><h4 id="2-1-现有序列化系统的运作流程（学习理解）"><a href="#2-1-现有序列化系统的运作流程（学习理解）" class="headerlink" title="2.1 现有序列化系统的运作流程（学习理解）"></a>2.1 现有序列化系统的运作流程（学习理解）</h4><p>通过参考同事的指导和已有的项目代码，我理解了一个成熟的资源加载系统通常遵循以下流程：</p><p><strong>A. 资源注册与系统启动</strong></p><ol><li><strong>特定目录扫描：</strong> 项目启动时，系统会遍历本地资源存储的默认目录。</li><li><strong>资源识别：</strong> 系统会读取文件，识别其<strong>资源类型</strong>和<strong>唯一标识符</strong>（通常是 <strong>GUID&#x2F;UUID</strong>）。</li><li><strong>系统注册：</strong> 所有资源类型必须预先在系统内完成注册，这是系统识别和处理新资源类型的前提。</li></ol><p><strong>B. 反序列化入口与依赖加载</strong></p><ol><li><strong>反序列化入口：</strong> 任何需要加载的“场景”或“进度”（如 UE 的 Level 文件或存档文件）都充当反序列化的起始点。</li><li><strong>依赖引用：</strong> 这个入口文件并不存储所有资源的完整数据，而是存储了它所依赖的<strong>其他资源文件</strong>的 <strong>GUID</strong>。</li><li><strong>级联加载：</strong> 反序列化系统会自动读取这些 GUID，并触发相应资源的加载和反序列化，从而实现<strong>加载一个文件，还原一个完整对象集合</strong>的功能。</li></ol><h4 id="2-2-在现有系统中添加新资源类型"><a href="#2-2-在现有系统中添加新资源类型" class="headerlink" title="2.2 在现有系统中添加新资源类型"></a>2.2 在现有系统中添加新资源类型</h4><p>我的核心工作是在现有框架下添加支持我自定义模型的数据类型，并实现相应的读写逻辑：</p><ol><li><strong>定义数据结构：</strong> 确定我的模型参数信息如何映射到项目约定的文本格式（例如 JSON 结构）。</li><li><strong>实现解析工具：</strong><ul><li><strong>序列化器 (Serializer)：</strong> 编写逻辑将内存中的模型对象<strong>写入</strong>到本地的资源文本文件中。</li><li><strong>反序列化器 (Deserializer)：</strong> 编写逻辑从资源文本文件中<strong>读取</strong>数据，并将其<strong>重建</strong>为内存中的模型对象。</li></ul></li></ol><p>我的方法是参考项目中已经存在的资源类型实现，通过“模仿”和“扩展”来确保我的新资源类型能够被系统正确地注册和加载。</p>]]></content>
    
    
    <summary type="html">经过一周与反序列化的斗智斗勇，来讲讲学到的反序列化相关知识。文本有AI润色。</summary>
    
    
    
    
    <category term="UE" scheme="https://cadenxc.com/tags/UE/"/>
    
    <category term="C++" scheme="https://cadenxc.com/tags/C/"/>
    
    <category term="序列化" scheme="https://cadenxc.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>自定义模型的法线和UV杂谈</title>
    <link href="https://cadenxc.com/2025/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B3%95%E7%BA%BF%E5%92%8CUV%E6%9D%82%E8%B0%88/"/>
    <id>https://cadenxc.com/2025/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B3%95%E7%BA%BF%E5%92%8CUV%E6%9D%82%E8%B0%88/</id>
    <published>2025-09-27T09:18:41.000Z</published>
    <updated>2025-09-27T09:20:25.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><p>法线是顶点的属性。与模型的光滑组（软硬边）有关。软边就让法线用相邻的面法线做插值，硬边就是同一个顶点上有多个相邻面的面法线。<br>改法线是硬边或软边比较简单，如果是要实现特定的法线方向就没有这么简单了。</p><h2 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h2><p>UV 的范围是(0,0到1,1)<br>要做的就是把所有的分配到UV空间里。<br>模型的顶点对应在UV图里有一个UV坐标。在添加顶点的时候要确定顶点的3D空间的坐标和UV上的坐标。</p><p>UV的生成与顶点有关，所以为了美术方便，在添加UV时需要考虑顶点的位置，所以我的BevelCube这个模型在后面就改过了生成的逻辑。就分为了主面和倒角面，倒角部分就不细分了。<br>UV的本质是把顶点映射到UV平面上。给这个顶点指定一个UV图上的位置。</p><p>也许在一开始就和美术对对UV比较好，这样可以对模型网格生成有帮助，少走弯路。</p><p>UV是可以超过这个区域的（和我对接的美术说可以）；也可以重叠，比如正方体的六个面就放在这个 1 x 1 的区域完全重叠就好。</p><hr><p>仓库链接：<a href="https://gitee.com/satoshi657/moden-gen">ModenGen: Ue4使用ProceduralMeshComponent生成自定义模型。</a></p>]]></content>
    
    
    <summary type="html">最近给模型添加法线和UV的想法。</summary>
    
    
    
    
    <category term="程序化网格体" scheme="https://cadenxc.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%BD%91%E6%A0%BC%E4%BD%93/"/>
    
    <category term="法线" scheme="https://cadenxc.com/tags/%E6%B3%95%E7%BA%BF/"/>
    
    <category term="UV" scheme="https://cadenxc.com/tags/UV/"/>
    
  </entry>
  
  <entry>
    <title>ProceduralMesh转StaticMesh</title>
    <link href="https://cadenxc.com/2025/09/06/ProceduralMesh%E8%BD%ACStaticMesh/"/>
    <id>https://cadenxc.com/2025/09/06/ProceduralMesh%E8%BD%ACStaticMesh/</id>
    <published>2025-09-05T16:01:05.000Z</published>
    <updated>2025-09-27T04:15:48.109Z</updated>
    
    <content type="html"><![CDATA[<p>在ProceduralMeshComponent的细节面板上，有一个按键convert to static mesh，可以把你当前的PMC转换为静态模型。这个function的位置在<code>ProceduralMeshComponentDetails.cpp</code>，使用的是<code>FStaticMeshSourceModel</code>来构建。但是这个函数无法在运行时使用，因为有<code>FStaticMeshSourceModel&amp; AddSourceModel();</code>这个函数有<code>WITH_EDITORONLY_DATA</code>的宏限制。</p><p>如果想在运行时把程序化模型转换为静态模型该怎么办呢？这就要使用FMeshDescription了。下面贴一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UStaticMesh* <span class="title">AProceduralMeshActor::ConvertProceduralMeshToStaticMesh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 验证输入参数</span></span><br><span class="line">    <span class="keyword">if</span> (!ProceduralMeshComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> int32 NumSections = ProceduralMeshComponent-&gt;<span class="built_in">GetNumSections</span>();</span><br><span class="line">    <span class="keyword">if</span> (NumSections == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建一个临时的、只存在于内存中的UStaticMesh对象</span></span><br><span class="line">    UStaticMesh* StaticMesh = <span class="built_in">NewObject</span>&lt;UStaticMesh&gt;(</span><br><span class="line">        <span class="built_in">GetTransientPackage</span>(), NAME_None, RF_Public | RF_Standalone);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StaticMesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建并设置 FMeshDescription</span></span><br><span class="line">    FMeshDescription MeshDescription;</span><br><span class="line">    <span class="function">FStaticMeshAttributes <span class="title">Attributes</span><span class="params">(MeshDescription)</span></span>;</span><br><span class="line">    Attributes.<span class="built_in">Register</span>();  <span class="comment">// 这会注册包括材质槽名称在内的所有必要属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对多边形组材质槽名称属性的引用，以便后续设置</span></span><br><span class="line">    <span class="comment">// 这是将几何体与材质关联的关键</span></span><br><span class="line">    TPolygonGroupAttributesRef&lt;FName&gt; PolygonGroupMaterialSlotNames =</span><br><span class="line">        Attributes.<span class="built_in">GetPolygonGroupMaterialSlotNames</span>();</span><br><span class="line"></span><br><span class="line">    FMeshDescriptionBuilder MeshDescBuilder;</span><br><span class="line">    MeshDescBuilder.<span class="built_in">SetMeshDescription</span>(&amp;MeshDescription);</span><br><span class="line">    MeshDescBuilder.<span class="built_in">EnablePolyGroups</span>();</span><br><span class="line">    MeshDescBuilder.<span class="built_in">SetNumUVLayers</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从PMC数据填充 FMeshDescription</span></span><br><span class="line">    TMap&lt;FVector, FVertexID&gt; VertexMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int32 SectionIdx = <span class="number">0</span>; SectionIdx &lt; NumSections; ++SectionIdx)</span><br><span class="line">    &#123;</span><br><span class="line">        FProcMeshSection* SectionData =</span><br><span class="line">            ProceduralMeshComponent-&gt;<span class="built_in">GetProcMeshSection</span>(SectionIdx);</span><br><span class="line">        <span class="keyword">if</span> (!SectionData || SectionData-&gt;ProcVertexBuffer.<span class="built_in">Num</span>() &lt; <span class="number">3</span> ||</span><br><span class="line">            SectionData-&gt;ProcIndexBuffer.<span class="built_in">Num</span>() &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 开始材质设置修正 ---</span></span><br><span class="line">        <span class="comment">// a. 为每个材质段创建一个唯一的槽名称</span></span><br><span class="line">        <span class="type">const</span> FName MaterialSlotName =</span><br><span class="line">            <span class="built_in">FName</span>(*FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MaterialSlot_%d&quot;</span>), SectionIdx));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 将材质和槽名称添加到StaticMesh的材质列表中</span></span><br><span class="line">        <span class="comment">// 这会在最终的UStaticMesh上创建对应的材质槽</span></span><br><span class="line">        <span class="function">FStaticMaterial <span class="title">NewStaticMaterial</span><span class="params">(<span class="literal">nullptr</span>, MaterialSlotName)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化UV通道数据，避免ensure失败</span></span><br><span class="line">        NewStaticMaterial.UVChannelData.bInitialized = <span class="literal">true</span>;</span><br><span class="line">        NewStaticMaterial.UVChannelData.bOverrideDensities = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算UV密度（基于实际的UV数据）</span></span><br><span class="line">        <span class="comment">// 分析当前section的UV数据来计算合适的密度值</span></span><br><span class="line">        <span class="type">float</span> UVDensity = <span class="number">1.0f</span>; <span class="comment">// 默认密度</span></span><br><span class="line">        <span class="keyword">if</span> (SectionData-&gt;ProcVertexBuffer.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算UV坐标的范围</span></span><br><span class="line">            <span class="function">FVector2D <span class="title">MinUV</span><span class="params">(FLT_MAX, FLT_MAX)</span></span>;</span><br><span class="line">            <span class="function">FVector2D <span class="title">MaxUV</span><span class="params">(-FLT_MAX, -FLT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> FProcMeshVertex&amp; Vertex : SectionData-&gt;ProcVertexBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                MinUV.X = FMath::<span class="built_in">Min</span>(MinUV.X, Vertex.UV<span class="number">0.</span>X);</span><br><span class="line">                MinUV.Y = FMath::<span class="built_in">Min</span>(MinUV.Y, Vertex.UV<span class="number">0.</span>Y);</span><br><span class="line">                MaxUV.X = FMath::<span class="built_in">Max</span>(MaxUV.X, Vertex.UV<span class="number">0.</span>X);</span><br><span class="line">                MaxUV.Y = FMath::<span class="built_in">Max</span>(MaxUV.Y, Vertex.UV<span class="number">0.</span>Y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算UV范围</span></span><br><span class="line">            FVector2D UVRange = MaxUV - MinUV;</span><br><span class="line">            <span class="keyword">if</span> (UVRange.X &gt; <span class="number">0.0f</span> &amp;&amp; UVRange.Y &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 基于UV范围计算密度，范围越大密度越小</span></span><br><span class="line">                UVDensity = FMath::<span class="built_in">Clamp</span>(<span class="number">1.0f</span> / FMath::<span class="built_in">Max</span>(UVRange.X, UVRange.Y), <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置UV通道密度</span></span><br><span class="line">        <span class="keyword">for</span> (int32 UVIndex = <span class="number">0</span>; UVIndex &lt; <span class="number">4</span>; ++UVIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            NewStaticMaterial.UVChannelData.LocalUVDensities[UVIndex] = UVDensity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StaticMesh-&gt;StaticMaterials.<span class="built_in">Add</span>(NewStaticMaterial);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. 在MeshDescription中为这个材质段创建一个新的多边形组</span></span><br><span class="line">        <span class="type">const</span> FPolygonGroupID PolygonGroup = MeshDescBuilder.<span class="built_in">AppendPolygonGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. 将多边形组与我们刚刚创建的材质槽名称关联起来</span></span><br><span class="line">        <span class="comment">// 这是最关键的一步！</span></span><br><span class="line">        PolygonGroupMaterialSlotNames.<span class="built_in">Set</span>(PolygonGroup, MaterialSlotName);</span><br><span class="line">        <span class="comment">// --- 结束材质设置修正 ---</span></span><br><span class="line"></span><br><span class="line">        TArray&lt;FVertexInstanceID&gt; VertexInstanceIDs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> FProcMeshVertex&amp; ProcVertex : SectionData-&gt;ProcVertexBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            FVertexID VertexID;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FVertexID* FoundID = VertexMap.<span class="built_in">Find</span>(ProcVertex.Position))</span><br><span class="line">            &#123;</span><br><span class="line">                VertexID = *FoundID;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                VertexID = MeshDescBuilder.<span class="built_in">AppendVertex</span>(ProcVertex.Position);</span><br><span class="line">                VertexMap.<span class="built_in">Add</span>(ProcVertex.Position, VertexID);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FVertexInstanceID InstanceID = MeshDescBuilder.<span class="built_in">AppendInstance</span>(VertexID);</span><br><span class="line">            MeshDescBuilder.<span class="built_in">SetInstanceNormal</span>(InstanceID, ProcVertex.Normal);</span><br><span class="line">            MeshDescBuilder.<span class="built_in">SetInstanceUV</span>(InstanceID, ProcVertex.UV0, <span class="number">0</span>);</span><br><span class="line">            MeshDescBuilder.<span class="built_in">SetInstanceColor</span>(InstanceID, <span class="built_in">FVector4</span>(ProcVertex.Color));</span><br><span class="line">            VertexInstanceIDs.<span class="built_in">Add</span>(InstanceID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; SectionData-&gt;ProcIndexBuffer.<span class="built_in">Num</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &gt;= SectionData-&gt;ProcIndexBuffer.<span class="built_in">Num</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int32 Index1 = SectionData-&gt;ProcIndexBuffer[i + <span class="number">0</span>];</span><br><span class="line">            int32 Index2 = SectionData-&gt;ProcIndexBuffer[i + <span class="number">1</span>];</span><br><span class="line">            int32 Index3 = SectionData-&gt;ProcIndexBuffer[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Index1 &gt;= VertexInstanceIDs.<span class="built_in">Num</span>() ||</span><br><span class="line">                Index2 &gt;= VertexInstanceIDs.<span class="built_in">Num</span>() ||</span><br><span class="line">                Index3 &gt;= VertexInstanceIDs.<span class="built_in">Num</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FVertexInstanceID V1 = VertexInstanceIDs[Index1];</span><br><span class="line">            FVertexInstanceID V2 = VertexInstanceIDs[Index2];</span><br><span class="line">            FVertexInstanceID V3 = VertexInstanceIDs[Index3];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将三角形添加到指定了材质信息的PolygonGroup中</span></span><br><span class="line">            MeshDescBuilder.<span class="built_in">AppendTriangle</span>(V1, V2, V3, PolygonGroup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MeshDescription.<span class="built_in">Vertices</span>().<span class="built_in">Num</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 使用 FMeshDescription 构建 Static Mesh</span></span><br><span class="line">    TArray&lt;<span class="type">const</span> FMeshDescription*&gt; MeshDescPtrs;</span><br><span class="line">    MeshDescPtrs.<span class="built_in">Emplace</span>(&amp;MeshDescription);</span><br><span class="line">    UStaticMesh::FBuildMeshDescriptionsParams BuildParams;</span><br><span class="line">    BuildParams.bBuildSimpleCollision = <span class="literal">true</span>;  <span class="comment">// StaticMesh默认开启碰撞</span></span><br><span class="line"></span><br><span class="line">    StaticMesh-&gt;<span class="built_in">BuildFromMeshDescriptions</span>(MeshDescPtrs, BuildParams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理碰撞 - StaticMesh默认开启碰撞</span></span><br><span class="line">    &#123;</span><br><span class="line">        StaticMesh-&gt;<span class="built_in">CreateBodySetup</span>();</span><br><span class="line">        UBodySetup* NewBodySetup = StaticMesh-&gt;BodySetup;</span><br><span class="line">        <span class="keyword">if</span> (NewBodySetup)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果PMC有BodySetup，复制其碰撞数据</span></span><br><span class="line">            <span class="keyword">if</span> (ProceduralMeshComponent-&gt;ProcMeshBodySetup)</span><br><span class="line">            &#123;</span><br><span class="line">                NewBodySetup-&gt;AggGeom.ConvexElems =</span><br><span class="line">                    ProceduralMeshComponent-&gt;ProcMeshBodySetup-&gt;AggGeom.ConvexElems;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置碰撞参数</span></span><br><span class="line">            NewBodySetup-&gt;bGenerateMirroredCollision = <span class="literal">false</span>;</span><br><span class="line">            NewBodySetup-&gt;bDoubleSidedGeometry = <span class="literal">true</span>;</span><br><span class="line">            NewBodySetup-&gt;CollisionTraceFlag = CTF_UseDefault;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建物理网格</span></span><br><span class="line">            NewBodySetup-&gt;<span class="built_in">CreatePhysicsMeshes</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StaticMesh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在运行时ProceduralMesh转换为StaticMesh。我使用的Ue引擎版本是4.26.2。</summary>
    
    
    
    
    <category term="UE" scheme="https://cadenxc.com/tags/UE/"/>
    
    <category term="C++" scheme="https://cadenxc.com/tags/C/"/>
    
    <category term="程序化网格体" scheme="https://cadenxc.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%BD%91%E6%A0%BC%E4%BD%93/"/>
    
    <category term="ProceduralMeshComponent" scheme="https://cadenxc.com/tags/ProceduralMeshComponent/"/>
    
  </entry>
  
  <entry>
    <title>实现倒角立方体</title>
    <link href="https://cadenxc.com/2025/08/16/%E5%AE%9E%E7%8E%B0%E5%80%92%E8%A7%92%E7%AB%8B%E6%96%B9%E4%BD%93/"/>
    <id>https://cadenxc.com/2025/08/16/%E5%AE%9E%E7%8E%B0%E5%80%92%E8%A7%92%E7%AB%8B%E6%96%B9%E4%BD%93/</id>
    <published>2025-08-16T13:03:30.000Z</published>
    <updated>2025-08-16T13:14:49.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从平面到立体"><a href="#从平面到立体" class="headerlink" title="从平面到立体"></a>从平面到立体</h2><p>先实现是个普通的立方体。<br>一个普通的立方体对大家来说想必难度不大，我们来实现一个倒角立方体。<br>前面我们生成里了一个三角形，这次我们来做一个倒角立方体。</p><h2 id="实现基础立方体"><a href="#实现基础立方体" class="headerlink" title="实现基础立方体"></a>实现基础立方体</h2><p>我们需要的参数只有一个</p><ul><li><code>CubeSize</code> (立方体的尺寸)</li></ul><p>这个八个点我选择的是以原点（0,0,0）为中心的做法，使用HalfSize为每个点设置值。绘制的流程跟OpenGL类似，这里像是OpenGL的顶点数组。有图形学API的使用经验的，可以想想倒角的算法是怎样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> HalfSize = CubeSize * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">TArray&lt;FVector&gt; CorePoints;</span><br><span class="line">CorePoints.<span class="built_in">Reserve</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(-HalfSize, -HalfSize, -HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(HalfSize, -HalfSize, -HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(-HalfSize, HalfSize, -HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(HalfSize, HalfSize, -HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(-HalfSize, -HalfSize, HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(HalfSize, -HalfSize, HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(-HalfSize, HalfSize, HalfSize));</span><br><span class="line">CorePoints.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(HalfSize, HalfSize, HalfSize));</span><br></pre></td></tr></table></figure><p>八个面，用16个三角形既可。<br>生成面的方法是用两个三角形拼在一起组合为一个面。逆时针排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v0, v1, v2, v3 是按逆时针排列的四个顶点</span></span><br><span class="line"> <span class="built_in">AddTriangle</span>(V0, V1, V2);</span><br><span class="line"> <span class="built_in">AddTriangle</span>(V0, V2, V3);</span><br></pre></td></tr></table></figure><p>这个立方体有两种倒角，边缘倒角和角落倒角。<br>8个主面会向面的中心收缩，所以在就不能使用原始的点，要添加一个参数。</p><ul><li><code>BevelSize</code> ：倒角的大小，不能大于半径<br> 还有一个参数用来控制倒角的光滑度。</li><li><code>BevelSegments</code> ：倒角的面数</li></ul><h2 id="边缘倒角"><a href="#边缘倒角" class="headerlink" title="边缘倒角"></a>边缘倒角</h2><p>通过对法线插值来计算下一条倒角边的两个顶点的位置，然后与前面的边相连形成一个倒角面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FBevelCubeBuilder::GenerateEdgeBevels</span><span class="params">(<span class="type">const</span> TArray&lt;FVector&gt;&amp; CorePoints)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 边缘倒角定义结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FEdgeBevelDef</span></span><br><span class="line">    &#123;</span><br><span class="line">        int32 Core1Idx;</span><br><span class="line">        int32 Core2Idx;</span><br><span class="line">        FVector Normal1;</span><br><span class="line">        FVector Normal2;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义所有边缘的倒角数据</span></span><br><span class="line">    TArray&lt;FEdgeBevelDef&gt; EdgeDefs = &#123;</span><br><span class="line">        <span class="comment">// +X 方向的边缘</span></span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +Y 方向的边缘</span></span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>), <span class="built_in">FVector</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="built_in">FVector</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">6</span>, <span class="built_in">FVector</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), <span class="built_in">FVector</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>) &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +Z 方向的边缘</span></span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="built_in">FVector</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">2</span>, <span class="number">6</span>, <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>) &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="built_in">FVector</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每条边生成倒角</span></span><br><span class="line">    <span class="keyword">for</span> (int32 EdgeIndex = <span class="number">0</span>; EdgeIndex &lt; EdgeDefs.<span class="built_in">Num</span>(); ++EdgeIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FEdgeBevelDef&amp; EdgeDef = EdgeDefs[EdgeIndex];</span><br><span class="line">               EdgeIndex, EdgeDef.Core1Idx, EdgeDef.Core2Idx);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">GenerateEdgeStrip</span>(CorePoints, EdgeDef.Core1Idx, EdgeDef.Core2Idx, EdgeDef.Normal1, EdgeDef.Normal2);</span><br><span class="line">        </span><br><span class="line">               EdgeIndex, MeshData.<span class="built_in">GetVertexCount</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">           MeshData.<span class="built_in">GetVertexCount</span>(), MeshData.<span class="built_in">GetTriangleCount</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FBevelCubeBuilder::GenerateEdgeStrip</span><span class="params">(<span class="type">const</span> TArray&lt;FVector&gt;&amp; CorePoints, int32 Core1Idx, int32 Core2Idx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> FVector&amp; Normal1, <span class="type">const</span> FVector&amp; Normal2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           Core1Idx, Core2Idx);</span><br><span class="line">    </span><br><span class="line">    TArray&lt;int32&gt; PrevStripStartIndices;</span><br><span class="line">    TArray&lt;int32&gt; PrevStripEndIndices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int32 s = <span class="number">0</span>; s &lt;= Params.BevelSections; ++s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> Alpha = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(s) / Params.BevelSections;</span><br><span class="line">        FVector CurrentNormal = FMath::<span class="built_in">Lerp</span>(Normal1, Normal2, Alpha).<span class="built_in">GetSafeNormal</span>();</span><br><span class="line"></span><br><span class="line">        FVector PosStart = CorePoints[Core1Idx] + CurrentNormal * Params.BevelSize;</span><br><span class="line">        FVector PosEnd = CorePoints[Core2Idx] + CurrentNormal * Params.BevelSize;</span><br><span class="line"></span><br><span class="line">        <span class="function">FVector2D <span class="title">UV1</span><span class="params">(Alpha, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">        <span class="function">FVector2D <span class="title">UV2</span><span class="params">(Alpha, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        int32 VtxStart = <span class="built_in">GetOrAddVertex</span>(PosStart, CurrentNormal, UV1);</span><br><span class="line">        int32 VtxEnd = <span class="built_in">GetOrAddVertex</span>(PosEnd, CurrentNormal, UV2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span> &amp;&amp; PrevStripStartIndices.<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; PrevStripEndIndices.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AddQuad</span>(PrevStripStartIndices[<span class="number">0</span>], PrevStripEndIndices[<span class="number">0</span>], VtxEnd, VtxStart);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrevStripStartIndices = &#123; VtxStart &#125;;</span><br><span class="line">        PrevStripEndIndices = &#123; VtxEnd &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="角落倒角"><a href="#角落倒角" class="headerlink" title="角落倒角"></a>角落倒角</h2><p>思路一样，线换成了点，有三个方向的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FBevelCubeBuilder::GenerateCornerBevels</span><span class="params">(<span class="type">const</span> TArray&lt;FVector&gt;&amp; CorePoints)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (CorePoints.<span class="built_in">Num</span>() &lt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Invalid CorePoints array size. Expected 8 elements.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每个角落生成倒角</span></span><br><span class="line">    <span class="keyword">for</span> (int32 CornerIndex = <span class="number">0</span>; CornerIndex &lt; <span class="number">8</span>; ++CornerIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FVector&amp; CurrentCorePoint = CorePoints[CornerIndex];</span><br><span class="line"><span class="comment">// 这里的四个需要反转渲染方向的倒角是我在实现实现中面的渲染方向反了的。</span></span><br><span class="line"><span class="comment">//这里没有多调，也许用不同的连接方法可以更优雅一些。</span></span><br><span class="line">        <span class="type">bool</span> bSpecialCornerRenderingOrder = (CornerIndex == <span class="number">4</span> || CornerIndex == <span class="number">7</span> || CornerIndex == <span class="number">2</span> || CornerIndex == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算角落的轴向</span></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> SignX = FMath::<span class="built_in">Sign</span>(CurrentCorePoint.X);</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> SignY = FMath::<span class="built_in">Sign</span>(CurrentCorePoint.Y);</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> SignZ = FMath::<span class="built_in">Sign</span>(CurrentCorePoint.Z);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">const</span> FVector <span class="title">AxisX</span><span class="params">(SignX, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> FVector <span class="title">AxisY</span><span class="params">(<span class="number">0.0f</span>, SignY, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> FVector <span class="title">AxisZ</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, SignZ)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建顶点网格</span></span><br><span class="line">        TArray&lt;TArray&lt;int32&gt;&gt; CornerVerticesGrid;</span><br><span class="line">        CornerVerticesGrid.<span class="built_in">SetNum</span>(Params.BevelSections + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int32 Lat = <span class="number">0</span>; Lat &lt;= Params.BevelSections; ++Lat)</span><br><span class="line">        &#123;</span><br><span class="line">            CornerVerticesGrid[Lat].<span class="built_in">SetNum</span>(Params.BevelSections + <span class="number">1</span> - Lat);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成四分之一球体的顶点</span></span><br><span class="line">        <span class="keyword">for</span> (int32 Lat = <span class="number">0</span>; Lat &lt;= Params.BevelSections; ++Lat)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int32 Lon = <span class="number">0</span>; Lon &lt;= Params.BevelSections - Lat; ++Lon)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">float</span> LonAlpha = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(Lon) / Params.BevelSections;</span><br><span class="line">                <span class="type">const</span> <span class="type">float</span> LatAlpha = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(Lat) / Params.BevelSections;</span><br><span class="line"></span><br><span class="line">                TArray&lt;FVector&gt; Vertices = <span class="built_in">GenerateCornerVertices</span>(CurrentCorePoint, AxisX, AxisY, AxisZ, Lat, Lon);</span><br><span class="line">                <span class="keyword">if</span> (Vertices.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    FVector CurrentNormal = (AxisX * (<span class="number">1.0f</span> - LatAlpha - LonAlpha) +</span><br><span class="line">                        AxisY * LatAlpha +</span><br><span class="line">                        AxisZ * LonAlpha);</span><br><span class="line">                    CurrentNormal.<span class="built_in">Normalize</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="function">FVector2D <span class="title">UV</span><span class="params">(LonAlpha, LatAlpha)</span></span>;</span><br><span class="line">                    CornerVerticesGrid[Lat][Lon] = <span class="built_in">GetOrAddVertex</span>(Vertices[<span class="number">0</span>], CurrentNormal, UV);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成四分之一球体的三角形</span></span><br><span class="line">        <span class="keyword">for</span> (int32 Lat = <span class="number">0</span>; Lat &lt; Params.BevelSections; ++Lat)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int32 Lon = <span class="number">0</span>; Lon &lt; Params.BevelSections - Lat; ++Lon)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">GenerateCornerTriangles</span>(CornerVerticesGrid, Lat, Lon, bSpecialCornerRenderingOrder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FBevelCubeBuilder::GenerateCornerTriangles</span><span class="params">(<span class="type">const</span> TArray&lt;TArray&lt;int32&gt;&gt;&amp; CornerVerticesGrid, </span></span></span><br><span class="line"><span class="params"><span class="function">                                               int32 Lat, int32 Lon, <span class="type">bool</span> bSpecialOrder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> int32 V00 = CornerVerticesGrid[Lat][Lon];</span><br><span class="line">    <span class="type">const</span> int32 V10 = CornerVerticesGrid[Lat + <span class="number">1</span>][Lon];</span><br><span class="line">    <span class="type">const</span> int32 V01 = CornerVerticesGrid[Lat][Lon + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bSpecialOrder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddTriangle</span>(V00, V01, V10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddTriangle</span>(V00, V10, V01);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Lon + <span class="number">1</span> &lt; CornerVerticesGrid[Lat + <span class="number">1</span>].<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> int32 V11 = CornerVerticesGrid[Lat + <span class="number">1</span>][Lon + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bSpecialOrder)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AddTriangle</span>(V10, V01, V11);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AddTriangle</span>(V10, V11, V01);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">实现倒角立方体。记录一下我的学习经历。</summary>
    
    
    
    
    <category term="UE" scheme="https://cadenxc.com/tags/UE/"/>
    
    <category term="C++" scheme="https://cadenxc.com/tags/C/"/>
    
    <category term="程序化网格体" scheme="https://cadenxc.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%BD%91%E6%A0%BC%E4%BD%93/"/>
    
    <category term="ProceduralMeshComponent" scheme="https://cadenxc.com/tags/ProceduralMeshComponent/"/>
    
  </entry>
  
  <entry>
    <title>在虚幻引擎中用代码生成网格体：基础入门</title>
    <link href="https://cadenxc.com/2025/08/02/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E4%BD%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://cadenxc.com/2025/08/02/%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E4%BD%93%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2025-08-02T11:49:32.000Z</published>
    <updated>2025-08-02T11:55:42.136Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊如何在虚幻引擎（Unreal Engine, UE）中用代码生成网格体。我发现网上关于这方面的介绍相对较少，而我刚好正在深入学习这个主题。本文是这个系列的第一篇，将带你了解基础知识。</p><h2 id="介绍-ProceduralMeshComponent-插件"><a href="#介绍-ProceduralMeshComponent-插件" class="headerlink" title="介绍 ProceduralMeshComponent 插件"></a>介绍 <code>ProceduralMeshComponent</code> 插件</h2><p>虚幻引擎提供了一个非常有用的插件，叫做 <strong><code>ProceduralMeshComponent</code></strong>。它允许我们通过编程的方式动态创建和修改网格体。这有什么用呢？对我来说，学习这个是为了实现<strong>自定义模型</strong>。比如，你可以通过UE的参数，在编辑器或运行时实时调整一个立方体的边长，而不需要预先导入一个静态模型。</p><p>这个插件同时支持C++和蓝图，但我这里只介绍如何在C++中使用它。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>在开始编写代码之前，我们需要先配置项目以启用 <code>ProceduralMeshComponent</code> 插件。</p><ol><li><p><strong>修改构建文件：</strong> 找到你项目目录下的 <code>&lt;你的项目名&gt;.Build.cs</code> 文件。</p></li><li><p><strong>添加插件依赖：</strong> 在 <code>PublicDependencyModuleNames.AddRange</code> 后面的花括号中，添加 <code>&quot;ProceduralMeshComponent&quot;</code>。修改后的代码应该类似这样：</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">string</span>[] &#123;</span><br><span class="line">        <span class="string">&quot;Core&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CoreUObject&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Engine&quot;</span>,</span><br><span class="line">        <span class="string">&quot;InputCore&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ProceduralMeshComponent&quot;</span> <span class="comment">// 添加这一行</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>重新生成项目文件：</strong> 关闭虚幻引擎项目。删除项目根目录下的 <code>Binaries</code>、<code>Intermediate</code> 和 <code>Saved</code> 文件夹。然后，右键点击你的 <code>.uproject</code> 文件，选择“<strong>Generate Visual Studio Project Files</strong>”（生成 Visual Studio 项目文件）。这会确保插件正确编译。</p></li></ol><h2 id="使用-ProceduralMeshComponent"><a href="#使用-ProceduralMeshComponent" class="headerlink" title="使用 ProceduralMeshComponent"></a>使用 <code>ProceduralMeshComponent</code></h2><p>配置完成后，我们就可以开始编写代码了。</p><h3 id="1-包含头文件"><a href="#1-包含头文件" class="headerlink" title="1. 包含头文件"></a>1. 包含头文件</h3><p>在你的C++文件中，需要包含 <code>ProceduralMeshComponent</code> 的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProceduralMeshComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-创建一个Actor和组件"><a href="#2-创建一个Actor和组件" class="headerlink" title="2. 创建一个Actor和组件"></a>2. 创建一个Actor和组件</h3><p>首先，你需要创建一个继承自 <code>AActor</code> 的C++类。在这个Actor中，我们将添加一个 <code>UProceduralMeshComponent</code> 类型的指针成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyProceduralMeshActor.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProceduralMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyProceduralMeshActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MYPROJECT_API</span> AMyProceduralMeshActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AMyProceduralMeshActor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;Components&quot;</span>)</span><br><span class="line">    UProceduralMeshComponent* ProceduralMesh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GenerateMesh</span><span class="params">()</span></span>; <span class="comment">// 用于生成网格体的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 <code>.cpp</code> 文件中初始化组件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyProceduralMeshActor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyProceduralMeshActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AMyProceduralMeshActor::<span class="built_in">AMyProceduralMeshActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并设置ProceduralMeshComponent</span></span><br><span class="line">    ProceduralMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UProceduralMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;GeneratedMesh&quot;</span>));</span><br><span class="line">    RootComponent = ProceduralMesh; <span class="comment">// 将其设置为根组件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyProceduralMeshActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    <span class="built_in">GenerateMesh</span>(); <span class="comment">// 在Actor开始时生成网格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-理解核心函数：CreateMeshSection-LinearColor"><a href="#3-理解核心函数：CreateMeshSection-LinearColor" class="headerlink" title="3. 理解核心函数：CreateMeshSection_LinearColor"></a>3. 理解核心函数：<code>CreateMeshSection_LinearColor</code></h3><p><code>ProceduralMeshComponent</code> 提供了几个用于创建网格体的函数，它们的工作方式都非常相似。这里我们重点介绍一个最常用的函数：<code>CreateMeshSection_LinearColor</code>。</p><p><strong>函数声明：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateMeshSection_LinearColor</span><span class="params">(int32 SectionIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> TArray&lt;FVector&gt;&amp; Vertices,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> TArray&lt;int32&gt;&amp; Triangles,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> TArray&lt;FVector&gt;&amp; Normals,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> TArray&lt;FVector2D&gt;&amp; UV0,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> TArray&lt;FLinearColor&gt;&amp; VertexColors,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> TArray&lt;FProcMeshTangent&gt;&amp; Tangents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">bool</span> bCreateCollision,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">bool</span> bSRGBConversion = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的工作原理类似于 OpenGL 等图形编程中构建几何体的方法。你通过定义一系列的<strong>顶点（Vertices）</strong>、<strong>三角形索引（Triangles）</strong>，以及可选的<strong>法线（Normals）</strong>、<strong>UV坐标（UVs）</strong> 和<strong>顶点颜色（VertexColors）</strong> 来构建网格体。</p><h3 id="4-示例：生成一个简单的平面"><a href="#4-示例：生成一个简单的平面" class="headerlink" title="4. 示例：生成一个简单的平面"></a>4. 示例：生成一个简单的平面</h3><p>让我们在 <code>GenerateMesh</code> 方法中实现一个简单的平面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyProceduralMeshActor.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyProceduralMeshActor::GenerateMesh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TArray&lt;FVector&gt; Vertices;</span><br><span class="line">    TArray&lt;int32&gt; Triangles;</span><br><span class="line">    TArray&lt;FVector&gt; Normals;</span><br><span class="line">    TArray&lt;FVector2D&gt; UV0;</span><br><span class="line">    TArray&lt;FLinearColor&gt; VertexColors;</span><br><span class="line">    TArray&lt;FProcMeshTangent&gt; Tangents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义顶点</span></span><br><span class="line">    Vertices.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));      <span class="comment">// 索引 0</span></span><br><span class="line">    Vertices.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>));    <span class="comment">// 索引 1</span></span><br><span class="line">    Vertices.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>));    <span class="comment">// 索引 2</span></span><br><span class="line">    Vertices.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>));  <span class="comment">// 索引 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义三角形（逆时针顺序为正面）</span></span><br><span class="line">    Triangles.<span class="built_in">Add</span>(<span class="number">0</span>); <span class="comment">// 第一个三角形</span></span><br><span class="line">    Triangles.<span class="built_in">Add</span>(<span class="number">1</span>);</span><br><span class="line">    Triangles.<span class="built_in">Add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Triangles.<span class="built_in">Add</span>(<span class="number">1</span>); <span class="comment">// 第二个三角形</span></span><br><span class="line">    Triangles.<span class="built_in">Add</span>(<span class="number">3</span>);</span><br><span class="line">    Triangles.<span class="built_in">Add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义法线（所有顶点朝向 Z 轴正方向）</span></span><br><span class="line">    Normals.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    Normals.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    Normals.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    Normals.<span class="built_in">Add</span>(<span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 定义UV坐标</span></span><br><span class="line">    UV<span class="number">0.</span><span class="built_in">Add</span>(<span class="built_in">FVector2D</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    UV<span class="number">0.</span><span class="built_in">Add</span>(<span class="built_in">FVector2D</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    UV<span class="number">0.</span><span class="built_in">Add</span>(<span class="built_in">FVector2D</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    UV<span class="number">0.</span><span class="built_in">Add</span>(<span class="built_in">FVector2D</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 定义顶点颜色（白色）</span></span><br><span class="line">    VertexColors.<span class="built_in">Add</span>(<span class="built_in">FLinearColor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    VertexColors.<span class="built_in">Add</span>(<span class="built_in">FLinearColor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    VertexColors.<span class="built_in">Add</span>(<span class="built_in">FLinearColor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    VertexColors.<span class="built_in">Add</span>(<span class="built_in">FLinearColor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 调用创建函数</span></span><br><span class="line">    ProceduralMesh-&gt;<span class="built_in">CreateMeshSection_LinearColor</span>(</span><br><span class="line">        <span class="number">0</span>,              <span class="comment">// SectionIndex</span></span><br><span class="line">        Vertices,</span><br><span class="line">        Triangles,</span><br><span class="line">        Normals,</span><br><span class="line">        UV0,</span><br><span class="line">        VertexColors,</span><br><span class="line">        Tangents,       <span class="comment">// 暂不使用切线</span></span><br><span class="line">        <span class="literal">true</span>            <span class="comment">// 创建碰撞</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>AMyProceduralMeshActor</code> 拖拽到场景中，运行游戏，你就会看到一个由代码生成的白色平面！</p><h2 id="在编辑器中调试和预览（可选）"><a href="#在编辑器中调试和预览（可选）" class="headerlink" title="在编辑器中调试和预览（可选）"></a>在编辑器中调试和预览（可选）</h2><p>为了方便在不运行游戏的情况下，实时预览参数对网格体的影响，我们可以利用虚幻编辑器中的 <code>PostEditChangeProperty</code> 函数。</p><p>首先，在你的 <code>.h</code> 文件中，添加以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyProceduralMeshActor.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="comment">// 在编辑器中属性改变时调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PostEditChangeProperty</span><span class="params">(FPropertyChangedEvent&amp; PropertyChangedEvent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后，在 <code>.cpp</code> 文件中实现该函数。这里以一个虚构的 <code>CubeParameters</code> 结构体为例，你可以根据自己的项目需求进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyProceduralMeshActor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyProceduralMeshActor::PostEditChangeProperty</span><span class="params">(FPropertyChangedEvent&amp; PropertyChangedEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PostEditChangeProperty</span>(PropertyChangedEvent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否是需要实时预览的属性被修改</span></span><br><span class="line">    <span class="keyword">if</span> (PropertyChangedEvent.Property != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FName PropertyName = PropertyChangedEvent.Property-&gt;<span class="built_in">GetFName</span>();</span><br><span class="line">        <span class="keyword">if</span> (PropertyName == <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(FCubeParameters, CubeSize) ||</span><br><span class="line">            PropertyName == <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(FCubeParameters, SegmentCount))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当相关属性改变时，重新生成网格体</span></span><br><span class="line">            <span class="built_in">GenerateMesh</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这段代码利用了虚幻引擎的反射系统，它只在编辑器中编译和运行（由 <code>#if WITH_EDITOR</code> 宏控制）。每当你在 Actor 的 <strong>Details</strong> 面板中修改了特定属性，它就会自动调用 <code>GenerateMesh</code> 函数，让你即时看到变化。</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>这次我们只是简单介绍了 <code>ProceduralMeshComponent</code> 的基础用法。在下一篇文章中，我将深入讲解如何利用这些知识，一步步实现一个带有倒角（Bevel）效果的立方体。</p>]]></content>
    
    
    <summary type="html">我的学习记录，文章有AI润色。</summary>
    
    
    
    
    <category term="UE" scheme="https://cadenxc.com/tags/UE/"/>
    
    <category term="C++" scheme="https://cadenxc.com/tags/C/"/>
    
    <category term="程序化网格体" scheme="https://cadenxc.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%BD%91%E6%A0%BC%E4%BD%93/"/>
    
    <category term="ProceduralMeshComponent" scheme="https://cadenxc.com/tags/ProceduralMeshComponent/"/>
    
  </entry>
  
  <entry>
    <title>哲学和心理学书籍推荐</title>
    <link href="https://cadenxc.com/2025/07/12/%E5%93%B2%E5%AD%A6%E5%92%8C%E5%BF%83%E7%90%86%E5%AD%A6%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    <id>https://cadenxc.com/2025/07/12/%E5%93%B2%E5%AD%A6%E5%92%8C%E5%BF%83%E7%90%86%E5%AD%A6%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</id>
    <published>2025-07-12T09:41:24.000Z</published>
    <updated>2025-07-12T09:42:18.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>哲学通识课：<a href="https://book.douban.com/subject/27172839/">《苏菲的世界》</a></p><p>我个人比较喜欢斯多葛主义，下面列出我看过的相关书籍：</p><ul><li><a href="https://book.douban.com/subject/25867570/">《人生的智慧》</a></li><li><a href="https://book.douban.com/subject/5330333/">《活出生命的意义》</a></li><li><a href="https://book.douban.com/subject/36028579/">《斯多葛生活哲学》</a></li><li><a href="https://book.douban.com/subject/30313414/">《沉思录》</a></li><li><a href="https://book.douban.com/subject/27167270/">《像哲学家一样生活》</a></li><li><a href="https://book.douban.com/subject/36928235/">《障碍是道路》</a><br>可以在这个<a href="https://www.douban.com/doulist/151103535/">斯多葛主义书单</a>可以看看还有什么其它书。</li></ul><h2 id="心理学"><a href="#心理学" class="headerlink" title="心理学"></a>心理学</h2><p>这个和脑科学或者其他概念我不太好划分，有些可以放在其他分类里。这里就推这些吧。</p><p><a href="https://book.douban.com/subject/5330333/">《活出生命的意义》</a><br><a href="https://book.douban.com/subject/1775691/">《少有人走的路》</a><br><a href="https://book.douban.com/subject/30124849/">《改变的历程》</a><br><a href="https://book.douban.com/subject/26296636/">《心理控制方法》</a><br><a href="https://book.douban.com/subject/2368126/">《思考致富》</a><br><a href="https://book.douban.com/subject/30396172/">《论人的成长》</a></p>]]></content>
    
    
    <summary type="html">书籍推荐</summary>
    
    
    
    
    <category term="分享" scheme="https://cadenxc.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="书籍" scheme="https://cadenxc.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 Operating System Engineering Lab2 system calls</title>
    <link href="https://cadenxc.com/2025/07/03/MIT-6-S081-Operating-System-Engineering-Lab2-system-calls/"/>
    <id>https://cadenxc.com/2025/07/03/MIT-6-S081-Operating-System-Engineering-Lab2-system-calls/</id>
    <published>2025-07-03T00:51:27.000Z</published>
    <updated>2025-07-03T00:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册系统call"><a href="#注册系统call" class="headerlink" title="注册系统call"></a>注册系统call</h2><p>在以下文件里添加代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_trace]   sys_trace, <span class="comment">// add this line</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> mask; <span class="comment">//for tracing</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *syscall_names[] = &#123;</span><br><span class="line"><span class="string">&quot;placeholder&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line"><span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line"><span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>, <span class="string">&quot;sysinfo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">      <span class="keyword">if</span> ((p-&gt;mask &gt;&gt; num) &amp; <span class="number">1</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  np-&gt;mask = p-&gt;mask; <span class="comment">// copy mask from parent to child</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.c</span></span><br><span class="line">uint64 <span class="title function_">countproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">            count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line">uint64 <span class="title function_">kfreemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    uint64 total = <span class="number">0</span>; </span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next)</span><br><span class="line">        total += PGSIZE;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  uint64 addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  info.freemem = kfreemem();</span><br><span class="line">  info.nproc = countproc();</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"></summary>
    
    
    
    
    <category term="操作系统" scheme="https://cadenxc.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="6.S081" scheme="https://cadenxc.com/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 Operating System Engineering Lab1 Xv6 and Unix utilities</title>
    <link href="https://cadenxc.com/2025/06/27/MIT-6-S081-Operating-System-Engineering-Lab1-Xv6-and-Unix-utilities/"/>
    <id>https://cadenxc.com/2025/06/27/MIT-6-S081-Operating-System-Engineering-Lab1-Xv6-and-Unix-utilities/</id>
    <published>2025-06-27T02:14:52.000Z</published>
    <updated>2025-06-27T02:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>这个挺简单的，先给大家自信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sleep error: just need one argument. \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>这里fork之后，父子进程就有了相同的管道的文件描述符。</p><p>父进程先写入字符，然后等待子进程处理后接收传回来的字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        n = read(fds[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        write(fds[<span class="number">1</span>], buf, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(fds[<span class="number">1</span>], <span class="string">&quot;p&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        n = read(fds[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>网站上给的论文<a href="https://swtch.com/~rsc/thread/">Bell Labs and CSP Threads</a>很好得说明了原理。<br>我先没有用fork，只用pipe模拟了这个sieve。因为无法确定终止的循环数，而且网站上提示用递归，所以用迭代做这题是合理的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sieve</span><span class="params">(<span class="type">int</span> read_fd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(read_fd, buf, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        close(read_fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = buf[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        sieve(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span> (read(read_fd, buf, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">0</span>] % p != <span class="number">0</span>) &#123;</span><br><span class="line">                write(fds[<span class="number">1</span>], buf, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(read_fd);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    pipe(fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">        write(fds[<span class="number">1</span>], &amp;i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sieve(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>这个参考了ls.c。<br>c语言的字符串处理是这里较难的部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(target, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(target, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(getname(path), target) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, getname(buf));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> fname[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">                memmove(fname, de.name, DIRSIZ);</span><br><span class="line">                fname[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> cpath[<span class="number">512</span>];</span><br><span class="line">                <span class="type">int</span> path_len = <span class="built_in">strlen</span>(path);</span><br><span class="line">                memmove(cpath, path, path_len);</span><br><span class="line">                cpath[path_len] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                memmove(cpath + path_len + <span class="number">1</span>, fname, <span class="built_in">strlen</span>(fname));</span><br><span class="line">                cpath[path_len + <span class="number">1</span> + <span class="built_in">strlen</span>(fname)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (st.type == T_DIR) &#123;</span><br><span class="line"></span><br><span class="line">                    find(cpath, target);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_FILE) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, target) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s/&quot;</span>, path);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, fname);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find error: too few parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find error: too many parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;</span><br><span class="line">        find(<span class="string">&quot;.&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>我之前都没有用过这个命令，看<a href="https://ruanyifeng.com/blog/2019/08/xargs-tutorial.html">这篇文章</a>了解了它的功能，感觉挺好用的。</p><p>这里的思路简单，就是先把argv和管道运算符 <code>|</code> 传来的参数放在一个数组里，再用<code>fork</code>和<code>exec</code>执行。<br>前面的处理有几点要注意：</p><ul><li><code>|</code>传来的参数要从<code>0</code> 描述符里读取；</li><li>新数组要排除<code>argv[0]</code>，不然可能递归调用<code>xargs</code>；</li><li>从示例可知，<code>xargs</code>之后的参数要与前面的每一行拼接运行。</li></ul><p>没有写 -n 参数，评分系统也过了，不过要写也能写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">readline</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p = buf;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, p, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span> || *p == <span class="number">0</span>) &#123;</span><br><span class="line">            *p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != buf) &#123;</span><br><span class="line">        *p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: xargs command&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* arr[MAXARG];</span><br><span class="line">    <span class="type">char</span>* line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((line = readline()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> arr_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            arr[arr_index++] = argv[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* p = line;</span><br><span class="line">        <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">            <span class="keyword">while</span> (*p == <span class="string">&#x27; &#x27;</span>) p++;</span><br><span class="line">            <span class="keyword">if</span> (*p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span>* start = p;</span><br><span class="line">            <span class="keyword">while</span> (*p &amp;&amp; *p != <span class="string">&#x27; &#x27;</span>) p++;</span><br><span class="line">            <span class="type">int</span> len = p - start;</span><br><span class="line">            <span class="type">char</span>* arg = <span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!arg) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                arg[i] = start[i];</span><br><span class="line">            &#125;</span><br><span class="line">            arg[len] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            arr[arr_index++] = arg;</span><br><span class="line">            <span class="keyword">if</span> (arr_index &gt;= MAXARG - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[arr_index] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(arr[<span class="number">0</span>], arr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = argc - <span class="number">1</span>; i &lt; arr_index; i++) &#123;</span><br><span class="line">            <span class="built_in">free</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>写起来还蛮有意思的。</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/#_2">MIT 6.S081: Operating System Engineering - CS自学指南</a></p>]]></content>
    
    
    <summary type="html">实验一，写出来还挺有成就感的。</summary>
    
    
    
    
    <category term="操作系统" scheme="https://cadenxc.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="6.S081" scheme="https://cadenxc.com/tags/6-S081/"/>
    
  </entry>
  
  <entry>
    <title>新电脑配置指南</title>
    <link href="https://cadenxc.com/2025/06/16/%E6%96%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>https://cadenxc.com/2025/06/16/%E6%96%B0%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</id>
    <published>2025-06-16T02:37:04.000Z</published>
    <updated>2025-11-23T02:14:32.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础设置"><a href="#一、基础设置" class="headerlink" title="一、基础设置"></a>一、基础设置</h2><ul><li><p><strong>用户名设置</strong><br>系统激活注册时建议使用英文用户名。某些开发工具对路径兼容性较差，含中文可能导致异常。</p></li><li><p><strong>语言与界面优化</strong>  </p><ul><li>添加英文语言包，方便中英文切换。  </li><li>在任务栏设置中关闭“小组件”和“任务视图”，并隐藏搜索框，让界面更简洁清爽。</li></ul></li><li><p><strong>系统优化</strong>  </p><ul><li>将桌面路径迁移到 D 盘（或任意非 C 盘路径），减轻系统盘压力。  </li><li>打开以管理员身份运行的 PowerShell，执行以下命令关闭休眠功能，进一步节省 C 盘空间：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powercfg -h off</span><br></pre></td></tr></table></figure><blockquote><p><em>个人观点：Windows 的休眠功能并不理想，平时直接关机更为稳妥。</em></p></blockquote></li></ul></li><li><p><strong>安全策略调整</strong><br>在微软电脑管家（Microsoft PC Manager）中，将除 C 盘以外的所有磁盘添加为“信任磁盘”或“排除项”，避免开发时频繁弹出安全提示。</p></li></ul><hr><h2 id="二、D-盘目录结构"><a href="#二、D-盘目录结构" class="headerlink" title="二、D 盘目录结构"></a>二、D 盘目录结构</h2><p>为了避免路径问题，所有文件夹名使用英文，并统一集中管理：</p><ul><li><code>BrowserDownload</code>：浏览器下载目录</li><li><code>Caden</code>：我的英文名，放一些临时文件或杂项  </li><li><code>Code</code>：各类项目代码存放地  </li><li><code>NetworkDiskAndBtDownload</code>：网盘及 BT 下载文件存储  </li><li><code>Repositories</code>：存放从 GitHub 克隆下来的仓库  </li><li><code>Software</code>：软件下载目录</li></ul><hr><h2 id="三、软件安装与配置"><a href="#三、软件安装与配置" class="headerlink" title="三、软件安装与配置"></a>三、软件安装与配置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>安装 <strong>Google Chrome</strong>，并将其和系统自带的 <strong>Microsoft Edge</strong> 的默认下载路径设置为 <code>D:\BrowserDownload</code>。</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li><a href="https://git-scm.com/">Git</a></li><li><a href="https://git-fork.com/">Fork</a>：Git 图形界面工具</li><li><a href="https://github.com/PowerShell/PowerShell">PowerShell</a>：推荐配合 [Oh My Posh] 美化终端</li><li><a href="https://github.com/BeyondDimension/SteamTools">Watt Toolkit</a>：可用于 GitHub 下载加速</li></ul><h3 id="输入法与语言工具"><a href="#输入法与语言工具" class="headerlink" title="输入法与语言工具"></a>输入法与语言工具</h3><ul><li><a href="https://rime.im/">小狼毫输入法</a><br>配置 <a href="https://github.com/iDvel/rime-ice">雾凇拼音</a>，并使用小鹤双拼方案</li><li><a href="https://www.eudic.net/">欧陆词典</a>：好用的英文词典</li><li><a href="https://github.com/Pixpin/Pixpin">PixPin</a>：截图标注工具，开源且好用</li></ul><blockquote><p>可以移步到这篇 <a href="https://cadenxc.com/2025/06/02/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E6%8E%A8%E8%8D%90/">推荐博客</a>。</p></blockquote><hr><h2 id="四、数据迁移建议"><a href="#四、数据迁移建议" class="headerlink" title="四、数据迁移建议"></a>四、数据迁移建议</h2><ul><li><strong>浏览器数据</strong>：登录账号同步书签和插件即可。</li><li><strong>项目代码 &#x2F; 配置文件</strong>：使用 Git 进行云端同步，方便管理。</li><li><strong>敏感或私密数据</strong>：不建议上传云盘，可通过 U 盘或局域网方式传输。</li></ul><hr><p>如果你有什么建议，欢迎在评论区留言交流！</p>]]></content>
    
    
    <summary type="html">本文记录我配置新的Windows 11电脑的过程，包含个人的一些使用偏好，供有相似需求的朋友参考。</summary>
    
    
    
    <category term="经验分享" scheme="https://cadenxc.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Windows" scheme="https://cadenxc.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>《废都物语》游玩体验</title>
    <link href="https://cadenxc.com/2025/06/09/%E3%80%8A%E5%BA%9F%E9%83%BD%E7%89%A9%E8%AF%AD%E3%80%8B%E6%B8%B8%E7%8E%A9%E4%BD%93%E9%AA%8C/"/>
    <id>https://cadenxc.com/2025/06/09/%E3%80%8A%E5%BA%9F%E9%83%BD%E7%89%A9%E8%AF%AD%E3%80%8B%E6%B8%B8%E7%8E%A9%E4%BD%93%E9%AA%8C/</id>
    <published>2025-06-09T14:43:01.000Z</published>
    <updated>2025-06-09T14:49:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>尽量不剧透。</p><hr><p>这个游戏剧情融合了各种神话，虚构了一个丰富的大河世界。<br>主角有四个出身可以选，四个出身的线大体相同，但又有各自独特的剧情，每条线各自揭开了部分剧情的谜底。<br>可以在酒馆里集结队友，踏上旅途，像跑团。游戏内有多名队友，陪你冒险，都有着独特的个性，喜欢某位角色可以一直带着，可能会解锁队友个人的独特剧情。<br>在游戏过程中也有挺恶搞的地方，比如睡美人、怪仙，夜种王，也许会让你心领神会，忍俊不禁。</p><p>个人是按盗贼-&gt;骑士-&gt;法师-&gt;贤者的顺序玩了共计四周目，并不是那种多周目大佬。<br>游戏难度我选的普通，因为游戏的的多周目有继承机制，所以在我玩的周目里最难的是第一周目的盗贼出身。身板脆，不知道隐藏宝箱在哪里，对地图多大和谜题没有底，完全对世界陌生，这是我开荒的体验。</p><p>挺过初期的困难后就渐渐被玩法和剧情吸引了。 作为一个宝可梦爱好者，对西方奇幻和跑团也颇有兴趣的人，这个经典RPG战斗，那些非战斗的技能和以前宝可梦里的秘传技能等在战斗外的地方也可以使用的技能类似，龙与地下城式的队友集结和地图探险，不错。但是剧情就没有仔细看，以至于有的地方卡关查攻略了。不过这样也可以，我本来玩的时候也没有想着剧情会多优秀，到了后面几周目才渐渐琢磨出味道来，之后看了别人剧情梳理我才对剧情有一个完整的概念。</p><p>本来第一周目打得我都快弃坑了，不经意间在一次回档的时候没有选择打死龙蛋而是试着给它命名，结果孵出来了一个龙女，虽然这剧情有些熟悉但是我喜欢。想想这我之前不就算是错过了吗，鬼使神差让我读了一个前一点的档，出来一个龙女儿，这我得带着她通关呀。就继续打了，之后渐渐喜欢上了这个游戏。</p><p>游玩体验最好的是第四周目，打最终boss时，主角是贤者防御高，先给队友加攻加防，然后一直放回复技能就行，输出就靠队友，无脑点威力最高的技能。</p><p>别被画风劝退了，挺不错的。或者也可以等等重置版。</p>]]></content>
    
    
    <summary type="html">游戏不错。</summary>
    
    
    
    
    <category term="游戏" scheme="https://cadenxc.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎学习之旅（4）批渲染和调试</title>
    <link href="https://cadenxc.com/2025/06/08/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%884%EF%BC%89%E6%89%B9%E6%B8%B2%E6%9F%93%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <id>https://cadenxc.com/2025/06/08/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%884%EF%BC%89%E6%89%B9%E6%B8%B2%E6%9F%93%E5%92%8C%E8%B0%83%E8%AF%95/</id>
    <published>2025-06-08T08:19:38.000Z</published>
    <updated>2025-07-03T00:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次博客之后，先是抽象出了一个Renderer2D的类。这个类调用了是Renderer部分其他的代码，不知道OpenGL或者其他图形学API的具体实现如何。这样用户使用的时候只需要调用提供的静态函数就行了，图形学API是不影响用户写好的代码，是一个相当清晰的不错的设计。</p><p> 接下来就是在这个已经使用可以工作的Rednerer2D类里实现批渲染（Batch Rendering）。</p><p> 我对批渲染很有好感，这个得加进引擎里。之前用SDL2画地牢的地图时，我试着在更新初始化地图值时把绘制命令放在了for循环，导致每添加到一个图片到SDL_surface里就会调用一次绘制命令。这样地图绘制时是从上往下一点一点渲染，花了一百多秒完成。之后把绘制命令拿出for循环，这样就是在等Surface一次更新完后在绘制，地图一瞬间就绘制好了。</p><p>实现批渲染的方法。之前的实现是用一个数组存储，把位置纹理坐标等放在起，每个图形都是单独的一个数组，现在把数组改成结构体，不同的成员变量对应了不同属性，更新的值会插入在一个数组里。另有一个结构体来管理各种数值，前面的和纹理数组都在这个里面当成为变量。声明上述为一个静态结构体，每次调用是设置的数值等都在这里设置，这样在绘制的时候只使用结构体里的一个索引数组，渲染是就把前面的整个当成是一个图形绘制。</p><p>不过在添加纹理的时候出了一个Bug。我只绘制纯颜色块时正确，绘制带纹理的方块时候就是黑的，没有渲染出纹理，而本该是纯颜色的方块却有渲染出了纹理。</p><p>那就开始Debug吧。我先是查看代码，看了最近两次提交代码的修改部分，没发现问题。然后对这个错误进行测试，发现当绘制多个带纹理的方块时，本该是纯颜色的方块会渲染出最后一个绑定的纹理。问题出在了纹理设置上。当我在纹理渲染的函数里手动把slot 修改为0.0f时，渲染出了该有给的纹理，把slot设为没有纹理的绑定的值（比如3）就会变成默认的白色，说明这是纹理slot绑定出的问题。然后我找到了纹理绑定的那段代码，传了slot值（不指定就是默认复制的0），功能正常。</p><p>我有些震惊与这样的错误。我现在学习这个引擎的方式的流程如下。</p><ol><li>看一遍视频，了解本次代码该实现的效果；</li><li>点开GitHub对应提交的代码提交，理解代码的设计和实现；</li><li>编写代码；</li><li>改错；</li><li>提交到GitHub仓库。</li></ol><p>我再次看视频发现视频里是有传入参数的，所以这个提交的代码就没有达成视频里的功能。我默认认为代码要测试无误才提交，也相信这个是对的。但是TheCherno这个大牛居然在提交的时候没有注意到这个。</p><p>也许TheCherno是想提醒我要多思考，不要光剽窃代码。想告诉我大牛也会有不小心的时候，想说我也可以成为大牛。</p><p>谢谢你，TheCherno！</p>]]></content>
    
    
    <summary type="html">视频看到了第66节了。</summary>
    
    
    
    
    <category term="游戏引擎" scheme="https://cadenxc.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>代码之外的推荐</title>
    <link href="https://cadenxc.com/2025/06/02/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E6%8E%A8%E8%8D%90/"/>
    <id>https://cadenxc.com/2025/06/02/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E6%8E%A8%E8%8D%90/</id>
    <published>2025-06-02T11:59:47.000Z</published>
    <updated>2025-11-23T02:09:31.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h2><ul><li><a href="https://microsoftedge.microsoft.com/addons/detail/onetab/hoimpamkkoehapgenciaoajfkfkpgfop">OneTab</a>：压缩页面，减少内存占用，方便搜集临时的不想收藏的页面，配合浏览器的分组功能效果更佳；</li><li><a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/idghocbbahafpfhjnfhpbfbmpegphmmp?hl=zh-CN">沙拉查词</a>：聚合词典划词翻译；</li><li><a href="https://github.com/iorate/ublacklist">uBlacklist</a>：屏蔽网站用，清理 [内容农场]；</li><li><a href="https://microsoftedge.microsoft.com/addons/detail/get-rss-feed-url/pgbelohmepchkohpdldadopkblkgbjom">Get RSS Feed URL</a>：获取当前网页的RSS订阅；</li><li><a href="https://microsoftedge.microsoft.com/addons/detail/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8A%A9%E6%89%8B/iblnlnnpkbhnempmcbioeholmemingmo">微信读书笔记助手</a>：复制网页版微信读书画线评论；</li><li><a href="https://microsoftedge.microsoft.com/addons/detail/immersive-translate-tra/amkbmndfnliijdhojkpoglbnaaahippg">Immersive Translate</a>：内嵌式网页翻译；</li><li><a href="https://microsoftedge.microsoft.com/addons/detail/marinara-pomodoro%C2%AE-assis/ncpfbgmhdpgbgmdmkfcddiemjhebegin">Marinara: Pomodoro® Assistant</a>：一个番茄工作法的番茄钟；</li><li><a href="https://microsoftedge.microsoft.com/addons/detail/global-speed-%E8%A7%86%E9%A2%91%E9%80%9F%E5%BA%A6%E6%8E%A7%E5%88%B6/mjhlabbcmjflkpjknnicihkfnmbdfced?hl=zh-CN">Global Speed: 视频速度控制 - Microsoft Edge Addons</a>：视频速度控制。</li></ul><h2 id="Windows工具"><a href="#Windows工具" class="headerlink" title="Windows工具"></a>Windows工具</h2><ul><li><a href="https://www.sumatrapdfreader.org/free-pdf-reader">Sumatra PDF</a>：功能强大的电子书阅读器，可以打开多种电子书格式；</li><li><a href="https://rime.im/">小狼毫输入法</a>：好用的输入法软件；</li><li><a href="https://keepass.info/download.html">KeePass</a>：密码管理工具；</li><li><a href="https://geekuninstaller.com/">Geek</a>：知名卸载工具；</li><li><a href="https://www.cnblogs.com/hui-tong/p/18085042">Qbittorrent</a>：磁力下载软件，配合资源下载网址<a href="https://piratebayproxy.net/zh/">海盗湾</a>使用；</li><li><a href="https://sourceforge.net/projects/spacesniffer/">SpaceSniffer</a>：磁盘空间分析软件；</li><li><a href="https://github.com/easymodo/qimgv">qimgv</a>：图片浏览器：觉得Windows自带的图片显示不好用，可以试试这个；</li><li><a href="https://pixpin.cn/">PixPin</a>：截图贴图工具；</li><li><a href="https://apps.microsoft.com/detail/xp8bsbgqw2dks0?hl=zh-cn&gl=cn">PotPlayer</a>：可能是最好用的视频播放器；</li><li><a href="https://github.com/Wox-launcher/Wox">Wox</a>：调用了<a href="https://www.voidtools.com/zh-cn/">Everything</a>的软件快速启动器；</li><li><a href="https://obsidian.md/">Obsidian</a>：markdown笔记软件我选的这个，免费，双链笔记功能强大，推荐配合<a href="https://notes.oldwinter.top/%E5%B8%B8%E9%9D%92%E7%AC%94%E8%AE%B0">常青笔记</a>，<a href="https://forum-zh.obsidian.md/t/topic/134">下载插件</a>能让软件更好用；</li><li><a href="https://steampp.net/">Watt Toolkit</a>：加速器，连接 Github 和 Steam；</li><li><a href="https://mfiles.maokebing.com/">爱传送</a>：手机和电脑跨平台传送文件；</li><li><a href="https://zh-cn.libreoffice.org/">LibreOffice</a>：Wps和Micro Office的开源平替；</li><li><a href="https://www.gimp.org/">GIMP</a>：Adobe Photoshop 的开源平替；</li><li><a href="https://uuyc.163.com/">网易UU远程</a>：远程控制电脑；</li><li><a href="https://obsproject.com/?ref=openalternative.co">OBS</a>：开源视频录制软件；</li><li><a href="https://git-fork.com/">Fork</a>：Git 图形界面工具；</li><li><a href="https://cubox.pro/">Cubox</a>：跨平台浏览器页面管理；</li><li><a href="https://sourceforge.net/projects/fluent-reader.mirror/">Fluent Reader</a>：rss阅读器；</li><li><a href="https://twinkletray.com/">Twinkle Tray</a>：一个软件控制多个屏幕亮度；</li><li><a href="https://justgetflux.com/">f.lux</a>: 护眼工具；</li><li><a href="https://www.7zip.com/cn/">7Zip</a>：开源压缩软件。</li></ul><h2 id="安卓App"><a href="#安卓App" class="headerlink" title="安卓App"></a>安卓App</h2><p>在应用商店、github或者浏览器上能找到：</p><ul><li><a href="https://github.com/foobnix/LibreraReader">Librera</a>：阅读软件，可以打开Txt，PDF，Mobi等各种格式的文件；</li><li><a href="https://weread.qq.com/">微信读书</a>：电子书书城，阅读购买电子书；</li><li><a href="https://flomoapp.com/">flomo</a>：有浏览器页面，互传文字挺方便。</li><li><a href="https://habitica.com/">Habitica</a>：游戏化任务管理。</li><li>小宇宙：听播客；</li><li>ZArchiver&#x2F;MT Manager：手机文件管理，压缩包解压；</li></ul><h2 id="推荐学习的技能"><a href="#推荐学习的技能" class="headerlink" title="推荐学习的技能"></a>推荐学习的技能</h2><ul><li><a href="https://api.ihint.me/shuang/">双拼练习</a>：一种打字拼音输入法，有多种映射方式，选一种即可；</li><li><a href="https://markdown.com.cn/intro.html#markdown-%E6%98%AF%E4%BB%80%E4%B9%88">Markdown</a>：轻量级的标记语言，方便排版，写笔记，博客文章用；</li><li><a href="https://www.overleaf.com/learn">Latex</a>：一种编程语言，方便排版，写论文用。</li></ul>]]></content>
    
    
    <summary type="html">推荐一些非技术相关的浏览器插件/软件/技能。</summary>
    
    
    
    
    <category term="分享" scheme="https://cadenxc.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>《重构 改善既有代码的设计》简评</title>
    <link href="https://cadenxc.com/2025/05/29/%E3%80%8A%E9%87%8D%E6%9E%84%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AE%80%E8%AF%84/"/>
    <id>https://cadenxc.com/2025/05/29/%E3%80%8A%E9%87%8D%E6%9E%84%20%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AE%80%E8%AF%84/</id>
    <published>2025-05-29T12:43:21.000Z</published>
    <updated>2025-05-29T12:47:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>读<a href="https://book.douban.com/subject/30468596/">本书</a>的缘由看这里：<a href="https://cadenxc.com/2025/05/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%E6%B8%B2%E6%9F%93%E5%99%A8%E9%87%8D%E6%9E%84/">游戏引擎学习之旅（2）渲染器重构</a>。</p><p>我读完了感觉不错。和<a href="https://book.douban.com/subject/4199740/">《代码整洁之道》</a>一样，我现在还是一个新人，还没有没有遇到什么真实的复杂情况，有些需要重构的坏味道没有遇到，我就是凭我自己的感觉。</p><p>个人来说，他的前几章讲的思想原则就值得去看。</p><ul><li>重构的最佳时机是加入新功能之前；</li><li>重构要小步走；</li><li>何时不该重构；</li><li>重构会让开发更快。</li></ul><p>书的后面就是在讲重构的方法了，提供了一堆术语，方便和别人交流。这些反而就不是很重要了，需要的时候查表就行了。书在最后还贴心得给了一个坏味道与重构手法速查表。</p><p>确实是实用的书，当成词典就行了。</p>]]></content>
    
    
    <summary type="html">是一本久负盛名的书，经常会出现在推荐书单的书。</summary>
    
    
    
    
    <category term="书籍" scheme="https://cadenxc.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎学习之旅（3）渲染器重构</title>
    <link href="https://cadenxc.com/2025/05/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%E6%B8%B2%E6%9F%93%E5%99%A8%E9%87%8D%E6%9E%84/"/>
    <id>https://cadenxc.com/2025/05/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%E6%B8%B2%E6%9F%93%E5%99%A8%E9%87%8D%E6%9E%84/</id>
    <published>2025-05-27T03:17:19.000Z</published>
    <updated>2025-05-27T03:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重构的理由"><a href="#重构的理由" class="headerlink" title="重构的理由"></a>重构的理由</h2><p>跟着视频写为什么需要重构呢？你只需要从视频或者代码库里把东习 <em>steal</em> 出来不就行了吗？<br>这是因为我在看他的视频的时候感觉非常熟悉，他在讲 OpenGL 的时候抽象出了一个类似的渲染器（Renderer），我想就把学习 OpenGL 写的代码哪过来不久行了吗？。确实行了，屏幕上有预期的图片绘出。但是他的设计思路是把渲染的 API 和具体的图形学 API 的实现分开，方便后续扩展API，比如Vulkan，可以让使用引擎的人不知道渲染的具体实现。<br>我的当前的代码结构没有这个抽象的 API ，直接就是 OpenGL 的具体实现，这就我直接加上的代码就不合适了。于是就开启了重构工作。</p><h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>我从 The Cherno 那里 <em>steal</em> 了抽象 API ，我要做的就是让我的现在类继承抽象的 API 。我感觉没什么困难的，可是我基本上是第一次做这种类似的工作，修改了一处就报错，代码无法运行，有一种无从下手的感觉。从 The Cherno 那里 <em>steal</em> 的抽象 API是阻挡我修改的难关，不仅成员函数的参数和数量不同，里面的数据也进行了封装，成员变量的类型和数量不同，不能直接加上继承就让代码运行。种种限制让我对着代码发愁。这很挫败，难道我应该跟着视频走，回退到没有合并代码的版本吗？有没有什么技巧可以帮我重构呢？</p><p>还真有，我想起来了这本著名的<a href="https://book.douban.com/subject/30468597/">《重构 改善既有代码的设计》</a>，之前我一直用不上就没有读，现在是时候读读这本书了。这本书给了我很大的帮助。对我来说学到的重要的思想是：小步走，让代码保持可工作状态和重构会让开发更快。这让我静下心来，不想着一步到位，而是慢慢调整代码。我一步步得重构了原本的代码，并且加深了我对这整个渲染器的设计的理解。</p><h2 id="在重构中理解设计思路"><a href="#在重构中理解设计思路" class="headerlink" title="在重构中理解设计思路"></a>在重构中理解设计思路</h2><p> 我在The Cherno 的 Layout 的布局的 API 传入的参是 自定义的枚举类型，float2 就表示两个float类型的布局，把原本的类型和个数这个参数给些在了一起，我在用这个自定义类形的参数替代原来的 float 和 unsigned int 时， 想着这里，肯定有一个把这个变量变换为原来的两个的函数，我果然看到了两个相关的函数，一个计算大小，一个返回类型。</p><p> 他的顶点数组的创建用的是Create()函数，我之前没有意思到，我重构的时候意识才到这个函数的作用是让调用渲染器时只包含抽象 API 的头文件而不用与 具体的OpenGL类的图形学 API 的实现相关。</p><p>RendererAPI，RenderCommand，Renderer类之间的关系是后者调用前者。 渲染器的 Draw 和 Clear 是一个静态函数时，不用具体实现一个Renderer类。这里整个Renderer的实现的接口都是方便引擎的使用者调用。我在这里重构了几天既让用户方便，也让开发者有一个结构更加合理的代码库，方便后续开发。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p> 这种跟上思路的感觉很棒。</p><p>这次没有学太多的新东西，基本上是 OpenGL 系列里的东西，这是的重点是重构。</p><p>我确实做的是重构，写了几天，运行的结果还是和之前一模一样。难怪书里开头问了一个问题：如何跟经理解释重构的意义。</p><p>书里说重构的最佳时机就是在添加新功能之前，这个我也认同，我就是在添加相机功能之前重构代码。</p><p>提高了我重构的意识。当代码报了一个头文件循环包含的错误时，我想这是一个坏味道，就检查了其他的代码的头文件的包含，去掉多余的。</p><p>在重构的过程中真正学到了东西，而不是从theCherno那里steal。也难怪<a href="https://www.norvig.com/21-days.html">Peter Norvig说要learning by doing</a>了。</p><p> 我看书的时候意识到theCherno的教学中的代码也是在进行重构。先在屏幕上花画出一个三角型，在不改变显示效果的情况下对代码进行修改，提高代码的可读性和可扩展性，提高代码质量。</p>]]></content>
    
    
    <summary type="html">OpenGL渲染器的实现和重构</summary>
    
    
    
    
    <category term="游戏引擎" scheme="https://cadenxc.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎学习之旅（2）事件系统</title>
    <link href="https://cadenxc.com/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://cadenxc.com/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-05-20T06:38:50.000Z</published>
    <updated>2025-05-20T06:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频学到了<a href="https://www.bilibili.com/video/BV1mw41187Ac?spm_id_from=333.788.videopod.episodes&vd_source=c7d1bbd34d9982d8b421763e8204f67d&p=22">S022</a>，分析一下Hazel的事件系统是如何实现的。</p><span id="more"></span><p>先看看Application类里如何处理jj下面这里的 变量层栈的for循环里，if(e.Handled)为true，就退出不处理了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HZ_PROFILE_FUNCTION</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(e)</span></span>;</span><br><span class="line">dispatcher.<span class="built_in">Dispatch</span>&lt;WindowCloseEvent&gt;(<span class="built_in">HZ_BIND_EVENT_FN</span>(Application::OnWindowClose));</span><br><span class="line">dispatcher.<span class="built_in">Dispatch</span>&lt;WindowResizeEvent&gt;(<span class="built_in">HZ_BIND_EVENT_FN</span>(Application::OnWindowResize));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m_LayerStack.<span class="built_in">rbegin</span>(); it != m_LayerStack.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e.Handled) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">(*it)-&gt;<span class="built_in">OnEvent</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里显示用了一个dispatcher来处理窗口关闭和窗口重定义大小，这里的写法是判断事件类型是否符合传入的Callback处理函数，如果匹配了，就设置Handled为true（看下面的OnWindowClose返回的true，这样异或为true）。看下面的循环，Handled为true会直接退出。</p><figure class="highlight c++"><figcaption><span>dispatch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F will be deduced by the compiler</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dispatch</span><span class="params">(<span class="type">const</span> F&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>())</span><br><span class="line">&#123;</span><br><span class="line">m_Event.Handled |= <span class="built_in">func</span>(<span class="built_in">static_cast</span>&lt;T&amp;&gt;(m_Event));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Application::OnWindowClose</span><span class="params">(WindowCloseEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_Running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面这个事件处理返回的就是false，表示这个事件没有处理完，穿透层，下一层继续处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnMouseButtonPressedEvent</span><span class="params">(MouseButtonPressedEvent&amp; e)</span> </span>&#123;</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">io.MouseDown[e.<span class="built_in">GetMouseButton</span>()] = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">ET_CORE_TRACE</span>(e.<span class="built_in">ToString</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个Handled可以在层设置阻挡，ImGuiLayer这里的设置：<br>阻挡成功Handled就设置为true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_BlockEvents)</span><br><span class="line">&#123;</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">e.Handled |= e.<span class="built_in">IsInCategory</span>(EventCategoryMouse) &amp; io.WantCaptureMouse;</span><br><span class="line">e.Handled |= e.<span class="built_in">IsInCategory</span>(EventCategoryKeyboard) &amp; io.WantCaptureKeyboard;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何设置事件类型呢？<br>在事件发生的时候，glfw会自动调用下面我们在窗口初始化的时候设置的回调函数，这里的data.EventCallback(evnet)就是设置Event的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Set GLFW callbacks</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSetWindowSizeCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line"></span><br><span class="line">            data.Width = width;</span><br><span class="line"></span><br><span class="line">            data.Height = height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            WindowResizeEvent <span class="built_in">event</span>(width, height);</span><br><span class="line"></span><br><span class="line">            data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>data的类型就是下面的函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br></pre></td></tr></table></figure><p>这里提供了Event类型，EventDispatcher提供了处理事件的函数。<br>这就是我对整个事件系统的理解了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;视频学到了&lt;a href=&quot;https://www.bilibili.com/video/BV1mw41187Ac?spm_id_from=333.788.videopod.episodes&amp;vd_source=c7d1bbd34d9982d8b421763e8204f67d&amp;p=22&quot;&gt;S022&lt;/a&gt;，分析一下Hazel的事件系统是如何实现的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游戏引擎" scheme="https://cadenxc.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎学习之旅（1）</title>
    <link href="https://cadenxc.com/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89/"/>
    <id>https://cadenxc.com/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89/</id>
    <published>2025-05-12T11:28:57.000Z</published>
    <updated>2025-05-27T03:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>c++：</p><ul><li>学了CS106L，AP-1400，作业大部分完成了；<br>图形学基础：</li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101</a>的视频课程看完了，作业写到了MVP变换渲染小奶牛。<br>游戏引擎：</li><li><a href="https://games104.boomingtech.com/en/">GAMES104</a>的视频教程视频，没做作业;</li><li>学过<a href="https://www.libsdl.org/">SDL2</a>；</li><li>跟着Brackeys入门了Godot的基本操作，对游戏引擎要实现的有一个基本的概念。<br>软件工程：</li><li>读了一些经典书籍：《代码大全》《人月神话》《软件开发心理学》；</li><li>其他相关：《Doom启示录》。</li></ul><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>我先是学了两天的<a href="https://www.vulkan.org/">Vulkan</a>，然后看The Cherno 的 游戏引擎系列的s1~s15。</p><p>比较不自量力的是没有学过OpenGL，想着直接跳入Vulkan，自己用Vulkan写视频里的渲染部分代码。然后就发现Vulkan确实复杂，考虑到我以后很长一段时间都会向The Cherno学习，还是先去学习他的OpenGL系列比较好。而且他后面也用Vulkan，学会了OpenGL应该会让我更好学习Vulkan。</p><p>所以我就暂停学习引擎，去学习OpenGL了。现在看了20节的OpenGL，感觉OpenGL确实比Vulkan简单多了。绘制让我想到了SDL2，MVP变换让我想起了GAMES101，许多知识点开始连起来了。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>要有自知之明，脚踏实地。</p><p>The Cherno的视频确实很好，我学到了许多。</p><p>我接下来就是学习OpenGL，然后是学习游戏引擎，然后我就可以开始为Godot等开源代码做贡献了。</p><p>游戏和游戏引擎真的很有吸引力。游戏设计我不太懂，但是做游戏引擎的成就感和学到的技术是实打实的。技术成就真的会让我开心。</p><p>接下来的系列文章，大多是我的想法体会。如果你也在学习的路上，不妨来看看。</p>]]></content>
    
    
    <summary type="html">我过去12天的学习经历。</summary>
    
    
    
    
    <category term="游戏引擎" scheme="https://cadenxc.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>英语学习经验分享</title>
    <link href="https://cadenxc.com/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"/>
    <id>https://cadenxc.com/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/</id>
    <published>2025-05-09T14:37:24.000Z</published>
    <updated>2025-05-15T13:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。</p><span id="more"></span><p>下面是我学习英语的经验。</p><ul><li>把手机语言设置为英文；</li><li>读英文的技术书籍和文档；</li><li>看英文电影、动画；</li><li>把游戏语言调成英语；</li><li>写英文博客；</li><li>听英文播客。</li></ul><p>有些是一次性的。如把手机语言设置为英文。发朋友圈、微博说自己接下来要读完某本英文书，或是每天读半小时，通过一次轻松的行为安排了之后的一段时间。买一个会员，报个考试，通过公开承诺来约束自己。</p><p>最好的学习英语的方式就是用英语学习自己想学的东西。我在读英文技术书籍的时候会刻意挑选英文原版来锻炼自己的英文水平。国外大学的公开课英文的视频、网站和作业同时学技术和英文，是个一石二鸟的方式。</p><p>听播客是一个很好的英语输入途径。听不懂没关系，重要的是培养这个感觉。找到自己的i+1的材料，听就行了。</p><hr><p>资源推荐<br><a href="https://space.bilibili.com/323794482/video">罗肖尼Shawney的bilibili主页</a>，里面有有关英语学习的视频<br><a href="https://www.xiaoyuzhoufm.com/episode/631c9de1f3d15f16f4cc3270">牛顿探索加拿大的英语学习播客单集</a> ，别忘了shownote的书籍推荐<br><a href="https://book.douban.com/subject/35513147/">学会提问</a>，这本是提高写作技巧的书。<br><a href="https://store.steampowered.com/app/1265920/Life_is_Strange_Remastered/?l=schinese">Steam 上的 Life is Strange Remastered</a>，注意把语言调成英文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。&lt;/p&gt;</summary>
    
    
    
    
    <category term="英语" scheme="https://cadenxc.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>阅读《代码大全》</title>
    <link href="https://cadenxc.com/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/"/>
    <id>https://cadenxc.com/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/</id>
    <published>2025-04-27T10:26:23.000Z</published>
    <updated>2025-10-01T13:17:37.491Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/1477390/">《代码大全》</a>我读了两遍，先是读到英文版，后来又读了一边中文版。<br>读英文版时，我还想着“routine”该怎么翻译，结果看中文翻译翻成了“子程序”，意思没原文丰富。中英文版都不错完全推荐。</p><p>这本书讲的内容真的是软件工程的基础，跟我看完了感觉在各个方面长见识，但又很难说是什么，感觉就是为设计软件打了地基，知识成为了我的血液。书里的代码编写、变量命名、注释等我在其他的书籍视频里看过好几次，这本书把软件的方方面面串联起来，给了我一个大的脉络。先读这本书会为软件工程打一个很好的基础。</p><p>全书令我影响深刻的观点论述有：</p><ul><li>用隐喻来学习；</li><li>软件工程就是管理复杂度；</li><li>不要陷进语言，自己定义用法；</li><li>伪代码编程过程；</li><li>最后几章的关于人的个性，布局排版的艺术。</li></ul><p>有些东西确实不太懂，毕竟我还没有在真实的工业环境里工作过，设计、编码、测试等技能没有经过检验。不只这本书，《clean code》里的后半部分我就不懂；《程序开发心理学》我读得挺有意思，但是每章结束后问管理者和程序员的问题我无法回答；不过《人月神话》没有讨论什么技术，谈的是思想，写得也好，不愧对它的声誉。</p>]]></content>
    
    
    <summary type="html">《代码大全》（code complete），非常有名的书籍，虽然现在的版本还是2004年出的，依然没有过时。</summary>
    
    
    
    
    <category term="书籍" scheme="https://cadenxc.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
