<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CadenXc&#39;s Blog</title>
  
  
  <link href="https://cadenxc.com/atom.xml" rel="self"/>
  
  <link href="https://cadenxc.com/"/>
  <updated>2025-05-20T06:43:30.655Z</updated>
  <id>https://cadenxc.com/</id>
  
  <author>
    <name>CadenXc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏引擎学习之旅（2）事件系统</title>
    <link href="https://cadenxc.com/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://cadenxc.com/2025/05/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-05-20T06:38:50.000Z</published>
    <updated>2025-05-20T06:43:30.655Z</updated>
    
    <content type="html"><![CDATA[<p>视频学到了s22，分析一下Hazel的事件系统是如何实现的。</p><span id="more"></span><pre> <pre class="mermaid">graph TD A[GLFW 系统事件发生] --> B[创建 Event 子类实例] B --> C[调用 EventCallback(Event&)] C --> D[Application::OnEvent(e)] D --> E[EventDispatcher 判断是否为系统事件] E --> F[遍历 LayerStack，调用每层的 OnEvent] F --> G{e.Handled 为 true 吗？} G -- 是 --> H[停止事件传播] G -- 否 --> I[继续传播到下一层] ``` </pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">graph TD</span><br><span class="line">    A[GLFW 系统事件发生] --&gt; B[创建 Event 子类实例]</span><br><span class="line">    B --&gt; C[调用 EventCallback(Event&amp;)]</span><br><span class="line">    C --&gt; D[Application::OnEvent(e)]</span><br><span class="line">    D --&gt; E[EventDispatcher 判断是否为系统事件]</span><br><span class="line">    E --&gt; F[遍历 LayerStack，调用每层的 OnEvent]</span><br><span class="line">    F --&gt; G&#123;e.Handled 为 true 吗？&#125;</span><br><span class="line">    G -- 是 --&gt; H[停止事件传播]</span><br><span class="line">    G -- 否 --&gt; I[继续传播到下一层]&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先看看Application类里如何处理jj下面这里的 变量层栈的for循环里，if(e.Handled)为true，就退出不处理了</span><br><span class="line">```c++</span><br><span class="line">void Application::OnEvent(Event&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">HZ_PROFILE_FUNCTION();</span><br><span class="line"></span><br><span class="line">EventDispatcher dispatcher(e);</span><br><span class="line">dispatcher.Dispatch&lt;WindowCloseEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowClose));</span><br><span class="line">dispatcher.Dispatch&lt;WindowResizeEvent&gt;(HZ_BIND_EVENT_FN(Application::OnWindowResize));</span><br><span class="line"></span><br><span class="line">for (auto it = m_LayerStack.rbegin(); it != m_LayerStack.rend(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">if (e.Handled) </span><br><span class="line">break;</span><br><span class="line">(*it)-&gt;OnEvent(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里显示用了一个dispatcher来处理窗口关闭和窗口重定义大小，这里的写法是判断事件类型是否符合传入的Callback处理函数，如果匹配了，就设置Handled为true（看下面的OnWindowClose返回的true，这样异或为true）。看下面的循环，Handled为true会直接退出。</p><figure class="highlight c++"><figcaption><span>dispatch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F will be deduced by the compiler</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dispatch</span><span class="params">(<span class="type">const</span> F&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>())</span><br><span class="line">&#123;</span><br><span class="line">m_Event.Handled |= <span class="built_in">func</span>(<span class="built_in">static_cast</span>&lt;T&amp;&gt;(m_Event));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Application::OnWindowClose</span><span class="params">(WindowCloseEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_Running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面这个事件处理返回的就是false，表示这个事件没有处理完，穿透层，下一层继续处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnMouseButtonPressedEvent</span><span class="params">(MouseButtonPressedEvent&amp; e)</span> </span>&#123;</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">io.MouseDown[e.<span class="built_in">GetMouseButton</span>()] = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">ET_CORE_TRACE</span>(e.<span class="built_in">ToString</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个Handled可以在层设置阻挡，ImGuiLayer这里的设置：<br>阻挡成功Handled就设置为true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_BlockEvents)</span><br><span class="line">&#123;</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">e.Handled |= e.<span class="built_in">IsInCategory</span>(EventCategoryMouse) &amp; io.WantCaptureMouse;</span><br><span class="line">e.Handled |= e.<span class="built_in">IsInCategory</span>(EventCategoryKeyboard) &amp; io.WantCaptureKeyboard;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何设置事件类型呢？<br>在事件发生的时候，glfw会自动调用下面我们在窗口初始化的时候设置的回调函数，这里的data.EventCallback(evnet)就是设置Event的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Set GLFW callbacks</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glfwSetWindowSizeCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line"></span><br><span class="line">            data.Width = width;</span><br><span class="line"></span><br><span class="line">            data.Height = height;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            WindowResizeEvent <span class="built_in">event</span>(width, height);</span><br><span class="line"></span><br><span class="line">            data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>data的类型就是下面的函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br></pre></td></tr></table></figure><p>这里提供了Event类型，EventDispatcher提供了处理事件的函数。<br>这就是我对整个事件系统的理解了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;视频学到了s22，分析一下Hazel的事件系统是如何实现的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎学习之旅（一）</title>
    <link href="https://cadenxc.com/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://cadenxc.com/2025/05/12/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2025-05-12T11:28:57.000Z</published>
    <updated>2025-05-14T01:20:46.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>c++：</p><ul><li>学了CS106L，AP-1400，作业大部分完成了；<br>图形学基础：</li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101</a>的视频课程看完了，作业写到了MVP变换渲染小奶牛。<br>游戏引擎：</li><li><a href="https://games104.boomingtech.com/en/">GAMES104</a>的视频教程视频，没做作业;</li><li>学过<a href="https://www.libsdl.org/">SDL2</a>；</li><li>跟着Brackeys入门了Godot的基本操作，对游戏引擎要实现的有一个基本的概念。<br>软件工程：</li><li>读了一些经典书籍：《代码大全》《人月神话》《软件开发心理学》；</li><li>其他相关：《Doom启示录》。</li></ul><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>我先是学了两天的<a href="https://www.vulkan.org/">Vulkan</a>，然后看The Cherno 的 游戏引擎系列的s1~s15。</p><p>比较不自量力的是没有学过OpenGL，想着直接跳入Vulkan，自己用Vulkan写视频里的渲染部分代码。然后就发现Vulkan确实复杂，考虑到我以后很长一段时间都会向The Cherno学习，还是先去学习他的OpenGL系列比较好。而且他后面也用Vulkan，学会了OpenGL应该会让我更好学习Vulkan。</p><p>所以我就暂停学习引擎，去学习OpenGL了。现在看了20节的OpenGL，感觉OpenGL确实比Vulkan简单多了。绘制让我想到了SDL2，MVP变换让我想起了GAMES101，许多知识点开始连起来了。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>要有自知之明，脚踏实地。</p><p>The Cherno的视频确实很好，我学到了许多。</p><p>我接下来就是学习OpenGL，然后是学习游戏引擎，然后我就可以开始为Godot等开源代码做贡献了。</p><p>游戏和游戏引擎真的很有吸引力。游戏设计我不太懂，但是做游戏引擎的成就感和学到的技术是实打实的。技术成就真的会让我开心。</p><p>接下来的系列文章，大多是我的想法体会。如果你也在学习的路上，不妨来看看。</p>]]></content>
    
    
    <summary type="html">我过去12天的学习经历。</summary>
    
    
    
    
    <category term="游戏引擎" scheme="https://cadenxc.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>英语学习经验分享</title>
    <link href="https://cadenxc.com/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"/>
    <id>https://cadenxc.com/2025/05/09/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/</id>
    <published>2025-05-09T14:37:24.000Z</published>
    <updated>2025-05-15T13:15:43.179Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。</p><span id="more"></span><p>下面是我学习英语的经验。</p><ul><li>把手机语言设置为英文；</li><li>读英文的技术书籍和文档；</li><li>看英文电影、动画；</li><li>把游戏语言调成英语；</li><li>写英文博客；</li><li>听英文播客。</li></ul><p>有些是一次性的。如把手机语言设置为英文。发朋友圈、微博说自己接下来要读完某本英文书，或是每天读半小时，通过一次轻松的行为安排了之后的一段时间。买一个会员，报个考试，通过公开承诺来约束自己。</p><p>最好的学习英语的方式就是用英语学习自己想学的东西。我在读英文技术书籍的时候会刻意挑选英文原版来锻炼自己的英文水平。国外大学的公开课英文的视频、网站和作业同时学技术和英文，是个一石二鸟的方式。</p><p>听播客是一个很好的英语输入途径。听不懂没关系，重要的是培养这个感觉。找到自己的i+1的材料，听就行了。</p><hr><p>资源推荐<br><a href="https://space.bilibili.com/323794482/video">罗肖尼Shawney的bilibili主页</a>，里面有有关英语学习的视频<br><a href="https://www.xiaoyuzhoufm.com/episode/631c9de1f3d15f16f4cc3270">牛顿探索加拿大的英语学习播客单集</a> ，别忘了shownote的书籍推荐<br><a href="https://book.douban.com/subject/35513147/">学会提问</a>，这本是提高写作技巧的书。<br><a href="https://store.steampowered.com/app/1265920/Life_is_Strange_Remastered/?l=schinese">Steam 上的 Life is Strange Remastered</a>，注意把语言调成英文。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我觉得的正确学习方式是“克拉申二语习得假说“。简单来说就是可理解输入，让自己沉浸在英语环境中，就像孩子一样自然习得英语。&lt;/p&gt;</summary>
    
    
    
    
    <category term="英语" scheme="https://cadenxc.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>阅读《代码大全》</title>
    <link href="https://cadenxc.com/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/"/>
    <id>https://cadenxc.com/2025/04/27/%E9%98%85%E8%AF%BB%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B/</id>
    <published>2025-04-27T10:26:23.000Z</published>
    <updated>2025-05-19T10:54:52.718Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全》（code complete），非常有名的书籍，虽然现在的版本还是2004年出的，依然没有过时。</p><span id="more"></span><p>我读了两遍，先是读到英文版，后来又读了一边中文版。<br>读英文版时，我还想着“routine”该怎么翻译，结果看中文翻译翻成了“子程序”，意思没原文丰富。中英文版都不错完全推荐。</p><p>这本书讲的内容真的是软件工程的基础，跟我看完了感觉在各个方面长见识，但又很难说是什么，感觉就是为设计软件打了地基，知识成为了我的血液。书里的代码编写、变量命名、注释等我在其他的书籍视频里看过好几次，这本书把软件的方方面面串联起来，给了我一个大的画画。先读这本书会为软件工程打一个很好的基础。</p><p>全书令我影响深刻的观点论述有：</p><ul><li>用隐喻来学习；</li><li>软件工程就是管理复杂度；</li><li>不要陷进语言，自己定义用法；</li><li>伪代码编程过程；</li><li>最后几章的关于人的个性，布局排版的艺术。</li></ul><p>有些东西确实不太懂，毕竟我还没有在真实的工业环境里工作过，设计、编码、测试等技能没有经过检验。不只这本书，《clean code》里的后半部分我就不懂；《程序开发心理学》我读得挺有意思，但是每章结束后问管理者和程序员的问题我无法回答；不过《人月神话》没有讨论什么技术，谈的是思想，写得也好，不愧对它的声誉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《代码大全》（code complete），非常有名的书籍，虽然现在的版本还是2004年出的，依然没有过时。&lt;/p&gt;</summary>
    
    
    
    
    <category term="书籍" scheme="https://cadenxc.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
